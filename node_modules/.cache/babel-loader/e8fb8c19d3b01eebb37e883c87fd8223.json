{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\n\n\nclass MessageParser extends Transform {\n  constructor(options) {\n    super(options);\n    this.lastBytes = Buffer.alloc(4);\n    this.headersParsed = false;\n    this.headerBytes = 0;\n    this.headerChunks = [];\n    this.rawHeaders = false;\n    this.bodySize = 0;\n  }\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n\n\n  updateLastBytes(data) {\n    let lblen = this.lastBytes.length;\n    let nblen = Math.min(data.length, lblen); // shift existing bytes\n\n    for (let i = 0, len = lblen - nblen; i < len; i++) {\n      this.lastBytes[i] = this.lastBytes[i + nblen];\n    } // add new bytes\n\n\n    for (let i = 1; i <= nblen; i++) {\n      this.lastBytes[lblen - i] = data[data.length - i];\n    }\n  }\n  /**\n   * Finds and removes message headers from the remaining body. We want to keep\n   * headers separated until final delivery to be able to modify these\n   *\n   * @param {Buffer} data Next chunk of data\n   * @return {Boolean} Returns true if headers are already found or false otherwise\n   */\n\n\n  checkHeaders(data) {\n    if (this.headersParsed) {\n      return true;\n    }\n\n    let lblen = this.lastBytes.length;\n    let headerPos = 0;\n    this.curLinePos = 0;\n\n    for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n      let chr;\n\n      if (i < lblen) {\n        chr = this.lastBytes[i];\n      } else {\n        chr = data[i - lblen];\n      }\n\n      if (chr === 0x0a && i) {\n        let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n        let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n\n        if (pr1 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        } else if (pr1 === 0x0d && pr2 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        }\n      }\n    }\n\n    if (this.headersParsed) {\n      this.headerChunks.push(data.slice(0, headerPos));\n      this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.headerChunks = null;\n      this.emit('headers', this.parseHeaders());\n\n      if (data.length - 1 > headerPos) {\n        let chunk = data.slice(headerPos);\n        this.bodySize += chunk.length; // this would be the first chunk of data sent downstream\n\n        setImmediate(() => this.push(chunk));\n      }\n\n      return false;\n    } else {\n      this.headerBytes += data.length;\n      this.headerChunks.push(data);\n    } // store last 4 bytes to catch header break\n\n\n    this.updateLastBytes(data);\n    return false;\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    let headersFound;\n\n    try {\n      headersFound = this.checkHeaders(chunk);\n    } catch (E) {\n      return callback(E);\n    }\n\n    if (headersFound) {\n      this.bodySize += chunk.length;\n      this.push(chunk);\n    }\n\n    setImmediate(callback);\n  }\n\n  _flush(callback) {\n    if (this.headerChunks) {\n      let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.bodySize += chunk.length;\n      this.push(chunk);\n      this.headerChunks = null;\n    }\n\n    callback();\n  }\n\n  parseHeaders() {\n    let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n\n    for (let i = lines.length - 1; i > 0; i--) {\n      if (/^\\s/.test(lines[i])) {\n        lines[i - 1] += '\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    return lines.filter(line => line.trim()).map(line => ({\n      key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n      line\n    }));\n  }\n\n}\n\nmodule.exports = MessageParser;","map":{"version":3,"names":["Transform","require","MessageParser","constructor","options","lastBytes","Buffer","alloc","headersParsed","headerBytes","headerChunks","rawHeaders","bodySize","updateLastBytes","data","lblen","length","nblen","Math","min","i","len","checkHeaders","headerPos","curLinePos","chr","pr1","pr2","push","slice","concat","emit","parseHeaders","chunk","setImmediate","_transform","encoding","callback","from","headersFound","E","_flush","lines","toString","split","test","splice","filter","line","trim","map","key","substr","indexOf","toLowerCase","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/dkim/message-parser.js"],"sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}