{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst urllib = require('url');\n\nconst zlib = require('zlib');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst Cookies = require('./cookies');\n\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n  return nmfetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction nmfetch(url, options) {\n  options = options || {};\n  options.fetchRes = options.fetchRes || new PassThrough();\n  options.cookies = options.cookies || new Cookies();\n  options.redirects = options.redirects || 0;\n  options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n  if (options.cookie) {\n    [].concat(options.cookie || []).forEach(cookie => {\n      options.cookies.set(cookie, url);\n    });\n    options.cookie = false;\n  }\n\n  let fetchRes = options.fetchRes;\n  let parsed = urllib.parse(url);\n  let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n  let finished = false;\n  let cookies;\n  let body;\n  let handler = parsed.protocol === 'https:' ? https : http;\n  let headers = {\n    'accept-encoding': 'gzip,deflate',\n    'user-agent': 'nodemailer/' + packageData.version\n  };\n  Object.keys(options.headers || {}).forEach(key => {\n    headers[key.toLowerCase().trim()] = options.headers[key];\n  });\n\n  if (options.userAgent) {\n    headers['user-agent'] = options.userAgent;\n  }\n\n  if (parsed.auth) {\n    headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n  }\n\n  if (cookies = options.cookies.get(url)) {\n    headers.cookie = cookies;\n  }\n\n  if (options.body) {\n    if (options.contentType !== false) {\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n    }\n\n    if (typeof options.body.pipe === 'function') {\n      // it's a stream\n      headers['Transfer-Encoding'] = 'chunked';\n      body = options.body;\n      body.on('error', err => {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n      });\n    } else {\n      if (options.body instanceof Buffer) {\n        body = options.body;\n      } else if (typeof options.body === 'object') {\n        try {\n          // encodeURIComponent can fail on invalid input (partial emoji etc.)\n          body = Buffer.from(Object.keys(options.body).map(key => {\n            let value = options.body[key].toString().trim();\n            return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n          }).join('&'));\n        } catch (E) {\n          if (finished) {\n            return;\n          }\n\n          finished = true;\n          E.type = 'FETCH';\n          E.sourceUrl = url;\n          fetchRes.emit('error', E);\n          return;\n        }\n      } else {\n        body = Buffer.from(options.body.toString().trim());\n      }\n\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n      headers['Content-Length'] = body.length;\n    } // if method is not provided, use POST instead of GET\n\n\n    method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n  }\n\n  let req;\n  let reqOptions = {\n    method,\n    host: parsed.hostname,\n    path: parsed.path,\n    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n    headers,\n    rejectUnauthorized: false,\n    agent: false\n  };\n\n  if (options.tls) {\n    Object.keys(options.tls).forEach(key => {\n      reqOptions[key] = options.tls[key];\n    });\n  }\n\n  try {\n    req = handler.request(reqOptions);\n  } catch (E) {\n    finished = true;\n    setImmediate(() => {\n      E.type = 'FETCH';\n      E.sourceUrl = url;\n      fetchRes.emit('error', E);\n    });\n    return fetchRes;\n  }\n\n  if (options.timeout) {\n    req.setTimeout(options.timeout, () => {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      req.abort();\n      let err = new Error('Request Timeout');\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n    });\n  }\n\n  req.on('error', err => {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n    err.type = 'FETCH';\n    err.sourceUrl = url;\n    fetchRes.emit('error', err);\n  });\n  req.on('response', res => {\n    let inflate;\n\n    if (finished) {\n      return;\n    }\n\n    switch (res.headers['content-encoding']) {\n      case 'gzip':\n      case 'deflate':\n        inflate = zlib.createUnzip();\n        break;\n    }\n\n    if (res.headers['set-cookie']) {\n      [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n        options.cookies.set(cookie, url);\n      });\n    }\n\n    if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n      // redirect\n      options.redirects++;\n\n      if (options.redirects > options.maxRedirects) {\n        finished = true;\n        let err = new Error('Maximum redirect count exceeded');\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n        return;\n      } // redirect does not include POST body\n\n\n      options.method = 'GET';\n      options.body = false;\n      return nmfetch(urllib.resolve(url, res.headers.location), options);\n    }\n\n    fetchRes.statusCode = res.statusCode;\n    fetchRes.headers = res.headers;\n\n    if (res.statusCode >= 300 && !options.allowErrorResponse) {\n      finished = true;\n      let err = new Error('Invalid status code ' + res.statusCode);\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n      return;\n    }\n\n    res.on('error', err => {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n    });\n\n    if (inflate) {\n      res.pipe(inflate).pipe(fetchRes);\n      inflate.on('error', err => {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n      });\n    } else {\n      res.pipe(fetchRes);\n    }\n  });\n  setImmediate(() => {\n    if (body) {\n      try {\n        if (typeof body.pipe === 'function') {\n          return body.pipe(req);\n        } else {\n          req.write(body);\n        }\n      } catch (err) {\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        return;\n      }\n    }\n\n    req.end();\n  });\n  return fetchRes;\n}","map":{"version":3,"names":["http","require","https","urllib","zlib","PassThrough","Cookies","packageData","MAX_REDIRECTS","module","exports","url","options","nmfetch","fetchRes","cookies","redirects","maxRedirects","isNaN","cookie","concat","forEach","set","parsed","parse","method","toString","trim","toUpperCase","finished","body","handler","protocol","headers","version","Object","keys","key","toLowerCase","userAgent","auth","Authorization","Buffer","from","get","contentType","pipe","on","err","type","sourceUrl","emit","map","value","encodeURIComponent","join","E","length","req","reqOptions","host","hostname","path","port","rejectUnauthorized","agent","tls","request","setImmediate","timeout","setTimeout","abort","Error","res","inflate","createUnzip","includes","statusCode","location","resolve","allowErrorResponse","write","end"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/fetch/index.js"],"sourcesContent":["'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return nmfetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction nmfetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                try {\n                    // encodeURIComponent can fail on invalid input (partial emoji etc.)\n                    body = Buffer.from(\n                        Object.keys(options.body)\n                            .map(key => {\n                                let value = options.body[key].toString().trim();\n                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                            })\n                            .join('&')\n                    );\n                } catch (E) {\n                    if (finished) {\n                        return;\n                    }\n                    finished = true;\n                    E.type = 'FETCH';\n                    E.sourceUrl = url;\n                    fetchRes.emit('error', E);\n                    return;\n                }\n            } else {\n                body = Buffer.from(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            // redirect does not include POST body\n            options.method = 'GET';\n            options.body = false;\n            return nmfetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n        fetchRes.headers = res.headers;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}