{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst SMTPConnection = require('../smtp-connection');\n\nconst wellKnown = require('../well-known');\n\nconst shared = require('../shared');\n\nconst XOAuth2 = require('../xoauth2');\n\nconst packageData = require('../../package.json');\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\n\n\nclass SMTPTransport extends EventEmitter {\n  constructor(options) {\n    super();\n    options = options || {};\n\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n\n    let urlData;\n    let service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n      this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n\n    this.options = shared.assign(false, // create new object\n    options, // regular options\n    urlData, // url options\n    service && wellKnown(service) // wellknown options\n    );\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-transport'\n    }); // temporary object\n\n    let connection = new SMTPConnection(this.options);\n    this.name = 'SMTP';\n    this.version = packageData.version + '[client:' + connection.version + ']';\n\n    if (this.options.auth) {\n      this.auth = this.getAuth({});\n    }\n  }\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n\n\n  getSocket(options, callback) {\n    // return immediatelly\n    return setImmediate(() => callback(null, false));\n  }\n\n  getAuth(authOpts) {\n    if (!authOpts) {\n      return this.auth;\n    }\n\n    let hasAuth = false;\n    let authData = {};\n\n    if (this.options.auth && typeof this.options.auth === 'object') {\n      Object.keys(this.options.auth).forEach(key => {\n        hasAuth = true;\n        authData[key] = this.options.auth[key];\n      });\n    }\n\n    if (authOpts && typeof authOpts === 'object') {\n      Object.keys(authOpts).forEach(key => {\n        hasAuth = true;\n        authData[key] = authOpts[key];\n      });\n    }\n\n    if (!hasAuth) {\n      return false;\n    }\n\n    switch ((authData.type || '').toString().toUpperCase()) {\n      case 'OAUTH2':\n        {\n          if (!authData.service && !authData.user) {\n            return false;\n          }\n\n          let oauth2 = new XOAuth2(authData, this.logger);\n          oauth2.provisionCallback = this.mailer && this.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n          oauth2.on('token', token => this.mailer.emit('token', token));\n          oauth2.on('error', err => this.emit('error', err));\n          return {\n            type: 'OAUTH2',\n            user: authData.user,\n            oauth2,\n            method: 'XOAUTH2'\n          };\n        }\n\n      default:\n        return {\n          type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n          user: authData.user,\n          credentials: {\n            user: authData.user || '',\n            pass: authData.pass,\n            options: authData.options\n          },\n          method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false\n        };\n    }\n  }\n  /**\n   * Sends an e-mail using the selected settings\n   *\n   * @param {Object} mail Mail object\n   * @param {Function} callback Callback function\n   */\n\n\n  send(mail, callback) {\n    this.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let returned = false;\n      let options = this.options;\n\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || ''); // only copy options if we need to modify it\n\n        options = shared.assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n\n      let connection = new SMTPConnection(options);\n      connection.once('error', err => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        connection.close();\n        return callback(err);\n      });\n      connection.once('end', () => {\n        if (returned) {\n          return;\n        }\n\n        let timer = setTimeout(() => {\n          if (returned) {\n            return;\n          }\n\n          returned = true; // still have not returned, this means we have an unexpected connection close\n\n          let err = new Error('Unexpected socket close');\n\n          if (connection && connection._socket && connection._socket.upgrading) {\n            // starttls connection errors\n            err.code = 'ETLS';\n          }\n\n          callback(err);\n        }, 1000);\n\n        try {\n          timer.unref();\n        } catch (E) {// Ignore. Happens on envs with non-node timer implementation\n        }\n      });\n\n      let sendMessage = () => {\n        let envelope = mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n        let recipients = [].concat(envelope.to || []);\n\n        if (recipients.length > 3) {\n          recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n\n        if (mail.data.dsn) {\n          envelope.dsn = mail.data.dsn;\n        }\n\n        this.logger.info({\n          tnx: 'send',\n          messageId\n        }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n        connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n          returned = true;\n          connection.close();\n\n          if (err) {\n            this.logger.error({\n              err,\n              tnx: 'send'\n            }, 'Send error for %s: %s', messageId, err.message);\n            return callback(err);\n          }\n\n          info.envelope = {\n            from: envelope.from,\n            to: envelope.to\n          };\n          info.messageId = messageId;\n\n          try {\n            return callback(null, info);\n          } catch (E) {\n            this.logger.error({\n              err: E,\n              tnx: 'callback'\n            }, 'Callback error for %s: %s', messageId, E.message);\n          }\n        });\n      };\n\n      connection.connect(() => {\n        if (returned) {\n          return;\n        }\n\n        let auth = this.getAuth(mail.data.auth);\n\n        if (auth && (connection.allowsAuth || options.forceAuth)) {\n          connection.login(auth, err => {\n            if (auth && auth !== this.auth && auth.oauth2) {\n              auth.oauth2.removeAllListeners();\n            }\n\n            if (returned) {\n              return;\n            }\n\n            if (err) {\n              returned = true;\n              connection.close();\n              return callback(err);\n            }\n\n            sendMessage();\n          });\n        } else {\n          sendMessage();\n        }\n      });\n    });\n  }\n  /**\n   * Verifies SMTP configuration\n   *\n   * @param {Function} callback Callback function\n   */\n\n\n  verify(callback) {\n    let promise;\n\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n\n    this.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let options = this.options;\n\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n        options = shared.assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n\n      let connection = new SMTPConnection(options);\n      let returned = false;\n      connection.once('error', err => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        connection.close();\n        return callback(err);\n      });\n      connection.once('end', () => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        return callback(new Error('Connection closed'));\n      });\n\n      let finalize = () => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        connection.quit();\n        return callback(null, true);\n      };\n\n      connection.connect(() => {\n        if (returned) {\n          return;\n        }\n\n        let authData = this.getAuth({});\n\n        if (authData && (connection.allowsAuth || options.forceAuth)) {\n          connection.login(authData, err => {\n            if (returned) {\n              return;\n            }\n\n            if (err) {\n              returned = true;\n              connection.close();\n              return callback(err);\n            }\n\n            finalize();\n          });\n        } else if (!authData && connection.allowsAuth && options.forceAuth) {\n          let err = new Error('Authentication info was not provided');\n          err.code = 'NoAuth';\n          returned = true;\n          connection.close();\n          return callback(err);\n        } else {\n          finalize();\n        }\n      });\n    });\n    return promise;\n  }\n  /**\n   * Releases resources\n   */\n\n\n  close() {\n    if (this.auth && this.auth.oauth2) {\n      this.auth.oauth2.removeAllListeners();\n    }\n\n    this.emit('close');\n  }\n\n} // expose to the world\n\n\nmodule.exports = SMTPTransport;","map":{"version":3,"names":["EventEmitter","require","SMTPConnection","wellKnown","shared","XOAuth2","packageData","SMTPTransport","constructor","options","url","urlData","service","getSocket","parseConnectionUrl","assign","logger","getLogger","component","connection","name","version","auth","getAuth","callback","setImmediate","authOpts","hasAuth","authData","Object","keys","forEach","key","type","toString","toUpperCase","user","oauth2","provisionCallback","mailer","get","on","token","emit","err","method","credentials","pass","trim","authMethod","send","mail","socketOptions","returned","info","tnx","remoteAddress","remotePort","destHost","host","destPort","port","action","once","close","timer","setTimeout","Error","_socket","upgrading","code","unref","E","sendMessage","envelope","message","getEnvelope","messageId","recipients","concat","to","length","push","splice","data","dsn","join","createReadStream","error","from","connect","allowsAuth","forceAuth","login","removeAllListeners","verify","promise","Promise","resolve","reject","callbackPromise","finalize","quit","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/smtp-transport/index.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst XOAuth2 = require('../xoauth2');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nclass SMTPTransport extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-transport'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        if (this.options.auth) {\n            this.auth = this.getAuth({});\n        }\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    getAuth(authOpts) {\n        if (!authOpts) {\n            return this.auth;\n        }\n\n        let hasAuth = false;\n        let authData = {};\n\n        if (this.options.auth && typeof this.options.auth === 'object') {\n            Object.keys(this.options.auth).forEach(key => {\n                hasAuth = true;\n                authData[key] = this.options.auth[key];\n            });\n        }\n\n        if (authOpts && typeof authOpts === 'object') {\n            Object.keys(authOpts).forEach(key => {\n                hasAuth = true;\n                authData[key] = authOpts[key];\n            });\n        }\n\n        if (!hasAuth) {\n            return false;\n        }\n\n        switch ((authData.type || '').toString().toUpperCase()) {\n            case 'OAUTH2': {\n                if (!authData.service && !authData.user) {\n                    return false;\n                }\n                let oauth2 = new XOAuth2(authData, this.logger);\n                oauth2.provisionCallback = (this.mailer && this.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;\n                oauth2.on('token', token => this.mailer.emit('token', token));\n                oauth2.on('error', err => this.emit('error', err));\n                return {\n                    type: 'OAUTH2',\n                    user: authData.user,\n                    oauth2,\n                    method: 'XOAUTH2'\n                };\n            }\n            default:\n                return {\n                    type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n                    user: authData.user,\n                    credentials: {\n                        user: authData.user || '',\n                        pass: authData.pass,\n                        options: authData.options\n                    },\n                    method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false\n                };\n        }\n    }\n\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let returned = false;\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                // only copy options if we need to modify it\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n\n                let timer = setTimeout(() => {\n                    if (returned) {\n                        return;\n                    }\n                    returned = true;\n                    // still have not returned, this means we have an unexpected connection close\n                    let err = new Error('Unexpected socket close');\n                    if (connection && connection._socket && connection._socket.upgrading) {\n                        // starttls connection errors\n                        err.code = 'ETLS';\n                    }\n                    callback(err);\n                }, 1000);\n\n                try {\n                    timer.unref();\n                } catch (E) {\n                    // Ignore. Happens on envs with non-node timer implementation\n                }\n            });\n\n            let sendMessage = () => {\n                let envelope = mail.message.getEnvelope();\n                let messageId = mail.message.messageId();\n\n                let recipients = [].concat(envelope.to || []);\n                if (recipients.length > 3) {\n                    recipients.push('...and ' + recipients.splice(2).length + ' more');\n                }\n\n                if (mail.data.dsn) {\n                    envelope.dsn = mail.data.dsn;\n                }\n\n                this.logger.info(\n                    {\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Sending message %s to <%s>',\n                    messageId,\n                    recipients.join(', ')\n                );\n\n                connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n                    returned = true;\n                    connection.close();\n                    if (err) {\n                        this.logger.error(\n                            {\n                                err,\n                                tnx: 'send'\n                            },\n                            'Send error for %s: %s',\n                            messageId,\n                            err.message\n                        );\n                        return callback(err);\n                    }\n                    info.envelope = {\n                        from: envelope.from,\n                        to: envelope.to\n                    };\n                    info.messageId = messageId;\n                    try {\n                        return callback(null, info);\n                    } catch (E) {\n                        this.logger.error(\n                            {\n                                err: E,\n                                tnx: 'callback'\n                            },\n                            'Callback error for %s: %s',\n                            messageId,\n                            E.message\n                        );\n                    }\n                });\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let auth = this.getAuth(mail.data.auth);\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (auth && auth !== this.auth && auth.oauth2) {\n                            auth.oauth2.removeAllListeners();\n                        }\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        sendMessage();\n                    });\n                } else {\n                    sendMessage();\n                }\n            });\n        });\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let authData = this.getAuth({});\n\n                if (authData && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(authData, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else if (!authData && connection.allowsAuth && options.forceAuth) {\n                    let err = new Error('Authentication info was not provided');\n                    err.code = 'NoAuth';\n\n                    returned = true;\n                    connection.close();\n                    return callback(err);\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n\n    /**\n     * Releases resources\n     */\n    close() {\n        if (this.auth && this.auth.oauth2) {\n            this.auth.oauth2.removeAllListeners();\n        }\n        this.emit('close');\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPTransport;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}