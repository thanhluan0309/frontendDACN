{"ast":null,"code":"'use strict';\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst urllib = require('url');\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\n\n\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n  let proxy = urllib.parse(proxyUrl); // create a socket connection to the proxy server\n\n  let options;\n  let connect;\n  let socket;\n  options = {\n    host: proxy.hostname,\n    port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n  };\n\n  if (proxy.protocol === 'https:') {\n    // we can use untrusted proxies as long as we verify actual SMTP certificates\n    options.rejectUnauthorized = false;\n    connect = tls.connect.bind(tls);\n  } else {\n    connect = net.connect.bind(net);\n  } // Error harness for initial connection. Once connection is established, the responsibility\n  // to handle errors is passed to whoever uses this socket\n\n\n  let finished = false;\n\n  let tempSocketErr = err => {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n\n    try {\n      socket.destroy();\n    } catch (E) {// ignore\n    }\n\n    callback(err);\n  };\n\n  let timeoutErr = () => {\n    let err = new Error('Proxy socket timed out');\n    err.code = 'ETIMEDOUT';\n    tempSocketErr(err);\n  };\n\n  socket = connect(options, () => {\n    if (finished) {\n      return;\n    }\n\n    let reqHeaders = {\n      Host: destinationHost + ':' + destinationPort,\n      Connection: 'close'\n    };\n\n    if (proxy.auth) {\n      reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n    }\n\n    socket.write( // HTTP method\n    'CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\\r\\n' + // HTTP request headers\n    Object.keys(reqHeaders).map(key => key + ': ' + reqHeaders[key]).join('\\r\\n') + // End request\n    '\\r\\n\\r\\n');\n    let headers = '';\n\n    let onSocketData = chunk => {\n      let match;\n      let remainder;\n\n      if (finished) {\n        return;\n      }\n\n      headers += chunk.toString('binary');\n\n      if (match = headers.match(/\\r\\n\\r\\n/)) {\n        socket.removeListener('data', onSocketData);\n        remainder = headers.substr(match.index + match[0].length);\n        headers = headers.substr(0, match.index);\n\n        if (remainder) {\n          socket.unshift(Buffer.from(remainder, 'binary'));\n        } // proxy connection is now established\n\n\n        finished = true; // check response code\n\n        match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n\n        if (!match || (match[1] || '').charAt(0) !== '2') {\n          try {\n            socket.destroy();\n          } catch (E) {// ignore\n          }\n\n          return callback(new Error('Invalid response from proxy' + (match && ': ' + match[1] || '')));\n        }\n\n        socket.removeListener('error', tempSocketErr);\n        socket.removeListener('timeout', timeoutErr);\n        socket.setTimeout(0);\n        return callback(null, socket);\n      }\n    };\n\n    socket.on('data', onSocketData);\n  });\n  socket.setTimeout(httpProxyClient.timeout || 30 * 1000);\n  socket.on('timeout', timeoutErr);\n  socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;","map":{"version":3,"names":["net","require","tls","urllib","httpProxyClient","proxyUrl","destinationPort","destinationHost","callback","proxy","parse","options","connect","socket","host","hostname","port","Number","protocol","rejectUnauthorized","bind","finished","tempSocketErr","err","destroy","E","timeoutErr","Error","code","reqHeaders","Host","Connection","auth","Buffer","from","toString","write","Object","keys","map","key","join","headers","onSocketData","chunk","match","remainder","removeListener","substr","index","length","unshift","charAt","setTimeout","on","timeout","once","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js"],"sourcesContent":["'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // create a socket connection to the proxy server\n    let options;\n    let connect;\n    let socket;\n\n    options = {\n        host: proxy.hostname,\n        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n    };\n\n    if (proxy.protocol === 'https:') {\n        // we can use untrusted proxies as long as we verify actual SMTP certificates\n        options.rejectUnauthorized = false;\n        connect = tls.connect.bind(tls);\n    } else {\n        connect = net.connect.bind(net);\n    }\n\n    // Error harness for initial connection. Once connection is established, the responsibility\n    // to handle errors is passed to whoever uses this socket\n    let finished = false;\n    let tempSocketErr = err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        try {\n            socket.destroy();\n        } catch (E) {\n            // ignore\n        }\n        callback(err);\n    };\n\n    let timeoutErr = () => {\n        let err = new Error('Proxy socket timed out');\n        err.code = 'ETIMEDOUT';\n        tempSocketErr(err);\n    };\n\n    socket = connect(options, () => {\n        if (finished) {\n            return;\n        }\n\n        let reqHeaders = {\n            Host: destinationHost + ':' + destinationPort,\n            Connection: 'close'\n        };\n        if (proxy.auth) {\n            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n        }\n\n        socket.write(\n            // HTTP method\n            'CONNECT ' +\n                destinationHost +\n                ':' +\n                destinationPort +\n                ' HTTP/1.1\\r\\n' +\n                // HTTP request headers\n                Object.keys(reqHeaders)\n                    .map(key => key + ': ' + reqHeaders[key])\n                    .join('\\r\\n') +\n                // End request\n                '\\r\\n\\r\\n'\n        );\n\n        let headers = '';\n        let onSocketData = chunk => {\n            let match;\n            let remainder;\n\n            if (finished) {\n                return;\n            }\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n\n                // proxy connection is now established\n                finished = true;\n\n                // check response code\n                match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n                if (!match || (match[1] || '').charAt(0) !== '2') {\n                    try {\n                        socket.destroy();\n                    } catch (E) {\n                        // ignore\n                    }\n                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));\n                }\n\n                socket.removeListener('error', tempSocketErr);\n                socket.removeListener('timeout', timeoutErr);\n                socket.setTimeout(0);\n\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);\n    socket.on('timeout', timeoutErr);\n\n    socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}