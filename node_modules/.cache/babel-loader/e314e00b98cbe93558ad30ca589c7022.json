{"ast":null,"code":"'use strict';\n\nconst packageInfo = require('../../package.json');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst os = require('os');\n\nconst crypto = require('crypto');\n\nconst DataStream = require('./data-stream');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst shared = require('../shared'); // default timeout values in ms\n\n\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\n\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\n\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname \n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\n\nclass SMTPConnection extends EventEmitter {\n  constructor(options) {\n    super(options);\n    this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    this.stage = 'init';\n    this.options = options || {};\n    this.secureConnection = !!this.options.secure;\n    this.alreadySecured = !!this.options.secured;\n    this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n    this.host = this.options.host || 'localhost';\n    this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n\n    if (typeof this.options.secure === 'undefined' && this.port === 465) {\n      // if secure option is not set but port is 465, then default to secure\n      this.secureConnection = true;\n    }\n\n    this.name = this.options.name || this._getHostname();\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-connection',\n      sid: this.id\n    });\n    this.customAuth = new Map();\n    Object.keys(this.options.customAuth || {}).forEach(key => {\n      let mapKey = (key || '').toString().trim().toUpperCase();\n\n      if (!mapKey) {\n        return;\n      }\n\n      this.customAuth.set(mapKey, this.options.customAuth[key]);\n    });\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n\n    this.version = packageInfo.version;\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n\n    this.authenticated = false;\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n\n    this.destroyed = false;\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n\n    this.secure = !!this.secureConnection;\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n\n    this._remainder = '';\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n\n    this._responseQueue = [];\n    this.lastServerResponse = false;\n    /**\n     * The socket connecting to the server\n     * @publick\n     */\n\n    this._socket = false;\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n\n    this._supportedAuth = [];\n    /**\n     * Set to true, if EHLO response includes \"AUTH\".\n     * If false then authentication is not tried\n     */\n\n    this.allowsAuth = false;\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n\n    this._envelope = false;\n    /**\n     * Lists supported extensions\n     * @private\n     */\n\n    this._supportedExtensions = [];\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n\n    this._maxAllowedSize = 0;\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n\n    this._responseActions = [];\n    this._recipientQueue = [];\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n\n    this._greetingTimeout = false;\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n\n    this._connectionTimeout = false;\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n\n    this._destroyed = false;\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n\n    this._closing = false;\n    /**\n     * Callbacks for socket's listeners\n     */\n\n    this._onSocketData = chunk => this._onData(chunk);\n\n    this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n\n    this._onSocketClose = () => this._onClose();\n\n    this._onSocketEnd = () => this._onEnd();\n\n    this._onSocketTimeout = () => this._onTimeout();\n  }\n  /**\n   * Creates a connection to a SMTP server and sets up connection\n   * listener\n   */\n\n\n  connect(connectCallback) {\n    if (typeof connectCallback === 'function') {\n      this.once('connect', () => {\n        this.logger.debug({\n          tnx: 'smtp'\n        }, 'SMTP handshake finished');\n        connectCallback();\n      });\n\n      const isDestroyedMessage = this._isDestroyedMessage('connect');\n\n      if (isDestroyedMessage) {\n        return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n      }\n    }\n\n    let opts = {\n      port: this.port,\n      host: this.host,\n      allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n      timeout: this.options.dnsTimeout || DNS_TIMEOUT\n    };\n\n    if (this.options.localAddress) {\n      opts.localAddress = this.options.localAddress;\n    }\n\n    let setupConnectionHandlers = () => {\n      this._connectionTimeout = setTimeout(() => {\n        this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n      }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n      this._socket.on('error', this._onSocketError);\n    };\n\n    if (this.options.connection) {\n      // connection is already opened\n      this._socket = this.options.connection;\n\n      if (this.secureConnection && !this.alreadySecured) {\n        setImmediate(() => this._upgradeConnection(err => {\n          if (err) {\n            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n\n            return;\n          }\n\n          this._onConnect();\n        }));\n      } else {\n        setImmediate(() => this._onConnect());\n      }\n\n      return;\n    } else if (this.options.socket) {\n      // socket object is set up but not yet connected\n      this._socket = this.options.socket;\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n\n        try {\n          this._socket.connect(this.port, this.host, () => {\n            this._socket.setKeepAlive(true);\n\n            this._onConnect();\n          });\n\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    } else if (this.secureConnection) {\n      // connect using tls\n      if (this.options.tls) {\n        Object.keys(this.options.tls).forEach(key => {\n          opts[key] = this.options.tls[key];\n        });\n      }\n\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n\n        try {\n          this._socket = tls.connect(opts, () => {\n            this._socket.setKeepAlive(true);\n\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    } else {\n      // connect using plaintext\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n\n        try {\n          this._socket = net.connect(opts, () => {\n            this._socket.setKeepAlive(true);\n\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    }\n  }\n  /**\n   * Sends QUIT\n   */\n\n\n  quit() {\n    this._sendCommand('QUIT');\n\n    this._responseActions.push(this.close);\n  }\n  /**\n   * Closes the connection to the server\n   */\n\n\n  close() {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    this._responseActions = []; // allow to run this function only once\n\n    if (this._closing) {\n      return;\n    }\n\n    this._closing = true;\n    let closeMethod = 'end';\n\n    if (this.stage === 'init') {\n      // Close the socket immediately when connection timed out\n      closeMethod = 'destroy';\n    }\n\n    this.logger.debug({\n      tnx: 'smtp'\n    }, 'Closing connection to the server using \"%s\"', closeMethod);\n    let socket = this._socket && this._socket.socket || this._socket;\n\n    if (socket && !socket.destroyed) {\n      try {\n        this._socket[closeMethod]();\n      } catch (E) {// just ignore\n      }\n    }\n\n    this._destroy();\n  }\n  /**\n   * Authenticate user\n   */\n\n\n  login(authData, callback) {\n    const isDestroyedMessage = this._isDestroyedMessage('login');\n\n    if (isDestroyedMessage) {\n      return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n    }\n\n    this._auth = authData || {}; // Select SASL authentication method\n\n    this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n    if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n      this._authMethod = 'XOAUTH2';\n    } else if (!this._authMethod || this._authMethod === 'XOAUTH2' && !this._auth.oauth2) {\n      // use first supported\n      this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n    }\n\n    if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n      if (this._auth.user && this._auth.pass) {\n        this._auth.credentials = {\n          user: this._auth.user,\n          pass: this._auth.pass,\n          options: this._auth.options\n        };\n      } else {\n        return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n      }\n    }\n\n    if (this.customAuth.has(this._authMethod)) {\n      let handler = this.customAuth.get(this._authMethod);\n      let lastResponse;\n      let returned = false;\n\n      let resolve = () => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authenticated',\n          method: this._authMethod\n        }, 'User %s authenticated', JSON.stringify(this._auth.user));\n        this.authenticated = true;\n        callback(null, true);\n      };\n\n      let reject = err => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n      };\n\n      let handlerResponse = handler({\n        auth: this._auth,\n        method: this._authMethod,\n        extensions: [].concat(this._supportedExtensions),\n        authMethods: [].concat(this._supportedAuth),\n        maxAllowedSize: this._maxAllowedSize || false,\n        sendCommand: (cmd, done) => {\n          let promise;\n\n          if (!done) {\n            promise = new Promise((resolve, reject) => {\n              done = shared.callbackPromise(resolve, reject);\n            });\n          }\n\n          this._responseActions.push(str => {\n            lastResponse = str;\n            let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n            let data = {\n              command: cmd,\n              response: str\n            };\n\n            if (codes) {\n              data.status = Number(codes[1]) || 0;\n\n              if (codes[2]) {\n                data.code = codes[2];\n              }\n\n              data.text = str.substr(codes[0].length);\n            } else {\n              data.text = str;\n              data.status = 0; // just in case we need to perform numeric comparisons\n            }\n\n            done(null, data);\n          });\n\n          setImmediate(() => this._sendCommand(cmd));\n          return promise;\n        },\n        resolve,\n        reject\n      });\n\n      if (handlerResponse && typeof handlerResponse.catch === 'function') {\n        // a promise was returned\n        handlerResponse.then(resolve).catch(reject);\n      }\n\n      return;\n    }\n\n    switch (this._authMethod) {\n      case 'XOAUTH2':\n        this._handleXOauth2Token(false, callback);\n\n        return;\n\n      case 'LOGIN':\n        this._responseActions.push(str => {\n          this._actionAUTH_LOGIN_USER(str, callback);\n        });\n\n        this._sendCommand('AUTH LOGIN');\n\n        return;\n\n      case 'PLAIN':\n        this._responseActions.push(str => {\n          this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand('AUTH PLAIN ' + Buffer.from( //this._auth.user+'\\u0000'+\n        '\\u0000' + // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + this._auth.credentials.pass, 'utf-8').toString('base64'), // log entry without passwords\n        'AUTH PLAIN ' + Buffer.from( //this._auth.user+'\\u0000'+\n        '\\u0000' + // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + '/* secret */', 'utf-8').toString('base64'));\n\n        return;\n\n      case 'CRAM-MD5':\n        this._responseActions.push(str => {\n          this._actionAUTH_CRAM_MD5(str, callback);\n        });\n\n        this._sendCommand('AUTH CRAM-MD5');\n\n        return;\n    }\n\n    return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n  }\n  /**\n   * Sends a message\n   *\n   * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n   * @param {Object} message String, Buffer or a Stream\n   * @param {Function} callback Callback to return once sending is completed\n   */\n\n\n  send(envelope, message, done) {\n    if (!message) {\n      return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n    }\n\n    const isDestroyedMessage = this._isDestroyedMessage('send message');\n\n    if (isDestroyedMessage) {\n      return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n    } // reject larger messages than allowed\n\n\n    if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n      return setImmediate(() => {\n        done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n      });\n    } // ensure that callback is only called once\n\n\n    let returned = false;\n\n    let callback = function () {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      done(...arguments);\n    };\n\n    if (typeof message.on === 'function') {\n      message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n    }\n\n    let startTime = Date.now();\n\n    this._setEnvelope(envelope, (err, info) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let envelopeTime = Date.now();\n\n      let stream = this._createSendStream((err, str) => {\n        if (err) {\n          return callback(err);\n        }\n\n        info.envelopeTime = envelopeTime - startTime;\n        info.messageTime = Date.now() - envelopeTime;\n        info.messageSize = stream.outByteCount;\n        info.response = str;\n        return callback(null, info);\n      });\n\n      if (typeof message.pipe === 'function') {\n        message.pipe(stream);\n      } else {\n        stream.write(message);\n        stream.end();\n      }\n    });\n  }\n  /**\n   * Resets connection state\n   *\n   * @param {Function} callback Callback to return once connection is reset\n   */\n\n\n  reset(callback) {\n    this._sendCommand('RSET');\n\n    this._responseActions.push(str => {\n      if (str.charAt(0) !== '2') {\n        return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n      }\n\n      this._envelope = false;\n      return callback(null, true);\n    });\n  }\n  /**\n   * Connection listener that is run when the connection to\n   * the server is opened\n   *\n   * @event\n   */\n\n\n  _onConnect() {\n    clearTimeout(this._connectionTimeout);\n    this.logger.info({\n      tnx: 'network',\n      localAddress: this._socket.localAddress,\n      localPort: this._socket.localPort,\n      remoteAddress: this._socket.remoteAddress,\n      remotePort: this._socket.remotePort\n    }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n\n    if (this._destroyed) {\n      // Connection was established after we already had canceled it\n      this.close();\n      return;\n    }\n\n    this.stage = 'connected'; // clear existing listeners for the socket\n\n    this._socket.removeListener('data', this._onSocketData);\n\n    this._socket.removeListener('timeout', this._onSocketTimeout);\n\n    this._socket.removeListener('close', this._onSocketClose);\n\n    this._socket.removeListener('end', this._onSocketEnd);\n\n    this._socket.on('data', this._onSocketData);\n\n    this._socket.once('close', this._onSocketClose);\n\n    this._socket.once('end', this._onSocketEnd);\n\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n\n    this._socket.on('timeout', this._onSocketTimeout);\n\n    this._greetingTimeout = setTimeout(() => {\n      // if still waiting for greeting, give up\n      if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n        this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n      }\n    }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n    this._responseActions.push(this._actionGreeting); // we have a 'data' listener set up so resume socket if it was paused\n\n\n    this._socket.resume();\n  }\n  /**\n   * 'data' listener for data coming from the server\n   *\n   * @event\n   * @param {Buffer} chunk Data chunk coming from the server\n   */\n\n\n  _onData(chunk) {\n    if (this._destroyed || !chunk || !chunk.length) {\n      return;\n    }\n\n    let data = (chunk || '').toString('binary');\n    let lines = (this._remainder + data).split(/\\r?\\n/);\n    let lastline;\n    this._remainder = lines.pop();\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (this._responseQueue.length) {\n        lastline = this._responseQueue[this._responseQueue.length - 1];\n\n        if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n          this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n          continue;\n        }\n      }\n\n      this._responseQueue.push(lines[i]);\n    }\n\n    if (this._responseQueue.length) {\n      lastline = this._responseQueue[this._responseQueue.length - 1];\n\n      if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n        return;\n      }\n    }\n\n    this._processResponse();\n  }\n  /**\n   * 'error' listener for the socket\n   *\n   * @event\n   * @param {Error} err Error object\n   * @param {String} type Error name\n   */\n\n\n  _onError(err, type, data, command) {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n\n    if (this._destroyed) {\n      // just ignore, already closed\n      // this might happen when a socket is canceled because of reached timeout\n      // but the socket timeout error itself receives only after\n      return;\n    }\n\n    err = this._formatError(err, type, data, command);\n    this.logger.error(data, err.message);\n    this.emit('error', err);\n    this.close();\n  }\n\n  _formatError(message, type, response, command) {\n    let err;\n\n    if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n      err = message;\n    } else {\n      err = new Error(message);\n    }\n\n    if (type && type !== 'Error') {\n      err.code = type;\n    }\n\n    if (response) {\n      err.response = response;\n      err.message += ': ' + response;\n    }\n\n    let responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n\n    if (responseCode) {\n      err.responseCode = responseCode;\n    }\n\n    if (command) {\n      err.command = command;\n    }\n\n    return err;\n  }\n  /**\n   * 'close' listener for the socket\n   *\n   * @event\n   */\n\n\n  _onClose() {\n    this.logger.info({\n      tnx: 'network'\n    }, 'Connection closed');\n\n    if (this.upgrading && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n    } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n    }\n\n    this._destroy();\n  }\n  /**\n   * 'end' listener for the socket\n   *\n   * @event\n   */\n\n\n  _onEnd() {\n    if (this._socket && !this._socket.destroyed) {\n      this._socket.destroy();\n    }\n  }\n  /**\n   * 'timeout' listener for the socket\n   *\n   * @event\n   */\n\n\n  _onTimeout() {\n    return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n  }\n  /**\n   * Destroys the client, emits 'end'\n   */\n\n\n  _destroy() {\n    if (this._destroyed) {\n      return;\n    }\n\n    this._destroyed = true;\n    this.emit('end');\n  }\n  /**\n   * Upgrades the connection to TLS\n   *\n   * @param {Function} callback Callback function to run when the connection\n   *        has been secured\n   */\n\n\n  _upgradeConnection(callback) {\n    // do not remove all listeners or it breaks node v0.10 as there's\n    // apparently a 'finish' event set that would be cleared as well\n    // we can safely keep 'error', 'end', 'close' etc. events\n    this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n\n\n    this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n\n    let socketPlain = this._socket;\n    let opts = {\n      socket: this._socket,\n      host: this.host\n    };\n    Object.keys(this.options.tls || {}).forEach(key => {\n      opts[key] = this.options.tls[key];\n    });\n    this.upgrading = true; // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n\n    try {\n      this._socket = tls.connect(opts, () => {\n        this.secure = true;\n        this.upgrading = false;\n\n        this._socket.on('data', this._onSocketData);\n\n        socketPlain.removeListener('close', this._onSocketClose);\n        socketPlain.removeListener('end', this._onSocketEnd);\n        return callback(null, true);\n      });\n    } catch (err) {\n      return callback(err);\n    }\n\n    this._socket.on('error', this._onSocketError);\n\n    this._socket.once('close', this._onSocketClose);\n\n    this._socket.once('end', this._onSocketEnd);\n\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n\n\n    this._socket.on('timeout', this._onSocketTimeout); // resume in case the socket was paused\n\n\n    socketPlain.resume();\n  }\n  /**\n   * Processes queued responses from the server\n   *\n   * @param {Boolean} force If true, ignores _processing flag\n   */\n\n\n  _processResponse() {\n    if (!this._responseQueue.length) {\n      return false;\n    }\n\n    let str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n\n    if (/^\\d+-/.test(str.split('\\n').pop())) {\n      // keep waiting for the final part of multiline response\n      return;\n    }\n\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'server'\n      }, str.replace(/\\r?\\n$/, ''));\n    }\n\n    if (!str.trim()) {\n      // skip unexpected empty lines\n      setImmediate(() => this._processResponse(true));\n    }\n\n    let action = this._responseActions.shift();\n\n    if (typeof action === 'function') {\n      action.call(this, str);\n      setImmediate(() => this._processResponse(true));\n    } else {\n      return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n    }\n  }\n  /**\n   * Send a command to the server, append \\r\\n\n   *\n   * @param {String} str String to be sent to the server\n   * @param {String} logStr Optional string to be used for logging instead of the actual string\n   */\n\n\n  _sendCommand(str, logStr) {\n    if (this._destroyed) {\n      // Connection already closed, can't send any more data\n      return;\n    }\n\n    if (this._socket.destroyed) {\n      return this.close();\n    }\n\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'client'\n      }, (logStr || str || '').toString().replace(/\\r?\\n$/, ''));\n    }\n\n    this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n  }\n  /**\n   * Initiates a new message by submitting envelope data, starting with\n   * MAIL FROM: command\n   *\n   * @param {Object} envelope Envelope object in the form of\n   *        {from:'...', to:['...']}\n   *        or\n   *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n   */\n\n\n  _setEnvelope(envelope, callback) {\n    let args = [];\n    let useSmtpUtf8 = false;\n    this._envelope = envelope || {};\n    this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n    this._envelope.to = [].concat(this._envelope.to || []).map(to => (to && to.address || to || '').toString().trim());\n\n    if (!this._envelope.to.length) {\n      return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n    }\n\n    if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n      return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n    } // check if the sender address uses only ASCII characters,\n    // otherwise require usage of SMTPUTF8 extension\n\n\n    if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n      useSmtpUtf8 = true;\n    }\n\n    for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n      if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n        return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n      } // check if the recipients addresses use only ASCII characters,\n      // otherwise require usage of SMTPUTF8 extension\n\n\n      if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n        useSmtpUtf8 = true;\n      }\n    } // clone the recipients array for latter manipulation\n\n\n    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n    this._envelope.rejected = [];\n    this._envelope.rejectedErrors = [];\n    this._envelope.accepted = [];\n\n    if (this._envelope.dsn) {\n      try {\n        this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n      } catch (err) {\n        return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n      }\n    }\n\n    this._responseActions.push(str => {\n      this._actionMAIL(str, callback);\n    }); // If the server supports SMTPUTF8 and the envelope includes an internationalized\n    // email address then append SMTPUTF8 keyword to the MAIL FROM command\n\n\n    if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n      args.push('SMTPUTF8');\n      this._usingSmtpUtf8 = true;\n    } // If the server supports 8BITMIME and the message might contain non-ascii bytes\n    // then append the 8BITMIME keyword to the MAIL FROM command\n\n\n    if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n      args.push('BODY=8BITMIME');\n      this._using8BitMime = true;\n    }\n\n    if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n      args.push('SIZE=' + this._envelope.size);\n    } // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the MAIL FROM command\n\n\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.ret) {\n        args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n      }\n\n      if (this._envelope.dsn.envid) {\n        args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n      }\n    }\n\n    this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n  }\n\n  _setDsnEnvelope(params) {\n    let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n\n    if (ret) {\n      switch (ret) {\n        case 'HDRS':\n        case 'HEADERS':\n          ret = 'HDRS';\n          break;\n\n        case 'FULL':\n        case 'BODY':\n          ret = 'FULL';\n          break;\n      }\n    }\n\n    if (ret && !['FULL', 'HDRS'].includes(ret)) {\n      throw new Error('ret: ' + JSON.stringify(ret));\n    }\n\n    let envid = (params.envid || params.id || '').toString() || null;\n    let notify = params.notify || null;\n\n    if (notify) {\n      if (typeof notify === 'string') {\n        notify = notify.split(',');\n      }\n\n      notify = notify.map(n => n.trim().toUpperCase());\n      let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n      let invaliNotify = notify.filter(n => !validNotify.includes(n));\n\n      if (invaliNotify.length || notify.length > 1 && notify.includes('NEVER')) {\n        throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n      }\n\n      notify = notify.join(',');\n    }\n\n    let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n\n    if (orcpt && orcpt.indexOf(';') < 0) {\n      orcpt = 'rfc822;' + orcpt;\n    }\n\n    return {\n      ret,\n      envid,\n      notify,\n      orcpt\n    };\n  }\n\n  _getDsnRcptToArgs() {\n    let args = []; // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the RCPT TO command\n\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.notify) {\n        args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n      }\n\n      if (this._envelope.dsn.orcpt) {\n        args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n      }\n    }\n\n    return args.length ? ' ' + args.join(' ') : '';\n  }\n\n  _createSendStream(callback) {\n    let dataStream = new DataStream();\n    let logStream;\n\n    if (this.options.lmtp) {\n      this._envelope.accepted.forEach((recipient, i) => {\n        let final = i === this._envelope.accepted.length - 1;\n\n        this._responseActions.push(str => {\n          this._actionLMTPStream(recipient, final, str, callback);\n        });\n      });\n    } else {\n      this._responseActions.push(str => {\n        this._actionSMTPStream(str, callback);\n      });\n    }\n\n    dataStream.pipe(this._socket, {\n      end: false\n    });\n\n    if (this.options.debug) {\n      logStream = new PassThrough();\n      logStream.on('readable', () => {\n        let chunk;\n\n        while (chunk = logStream.read()) {\n          this.logger.debug({\n            tnx: 'message'\n          }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n        }\n      });\n      dataStream.pipe(logStream);\n    }\n\n    dataStream.once('end', () => {\n      this.logger.info({\n        tnx: 'message',\n        inByteCount: dataStream.inByteCount,\n        outByteCount: dataStream.outByteCount\n      }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n    });\n    return dataStream;\n  }\n  /** ACTIONS **/\n\n  /**\n   * Will be run after the connection is created and the server sends\n   * a greeting. If the incoming message starts with 220 initiate\n   * SMTP session by sending EHLO command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionGreeting(str) {\n    clearTimeout(this._greetingTimeout);\n\n    if (str.substr(0, 3) !== '220') {\n      this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n\n      return;\n    }\n\n    if (this.options.lmtp) {\n      this._responseActions.push(this._actionLHLO);\n\n      this._sendCommand('LHLO ' + this.name);\n    } else {\n      this._responseActions.push(this._actionEHLO);\n\n      this._sendCommand('EHLO ' + this.name);\n    }\n  }\n  /**\n   * Handles server response for LHLO command. If it yielded in\n   * error, emit 'error', otherwise treat this as an EHLO response\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionLHLO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n\n      return;\n    }\n\n    this._actionEHLO(str);\n  }\n  /**\n   * Handles server response for EHLO command. If it yielded in\n   * error, try HELO instead, otherwise initiate TLS negotiation\n   * if STARTTLS is supported by the server or move into the\n   * authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionEHLO(str) {\n    let match;\n\n    if (str.substr(0, 3) === '421') {\n      this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n\n      return;\n    }\n\n    if (str.charAt(0) !== '2') {\n      if (this.options.requireTLS) {\n        this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n\n        return;\n      } // Try HELO instead\n\n\n      this._responseActions.push(this._actionHELO);\n\n      this._sendCommand('HELO ' + this.name);\n\n      return;\n    } // Detect if the server supports STARTTLS\n\n\n    if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n      this._sendCommand('STARTTLS');\n\n      this._responseActions.push(this._actionSTARTTLS);\n\n      return;\n    } // Detect if the server supports SMTPUTF8\n\n\n    if (/[ -]SMTPUTF8\\b/im.test(str)) {\n      this._supportedExtensions.push('SMTPUTF8');\n    } // Detect if the server supports DSN\n\n\n    if (/[ -]DSN\\b/im.test(str)) {\n      this._supportedExtensions.push('DSN');\n    } // Detect if the server supports 8BITMIME\n\n\n    if (/[ -]8BITMIME\\b/im.test(str)) {\n      this._supportedExtensions.push('8BITMIME');\n    } // Detect if the server supports PIPELINING\n\n\n    if (/[ -]PIPELINING\\b/im.test(str)) {\n      this._supportedExtensions.push('PIPELINING');\n    } // Detect if the server supports AUTH\n\n\n    if (/[ -]AUTH\\b/i.test(str)) {\n      this.allowsAuth = true;\n    } // Detect if the server supports PLAIN auth\n\n\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n      this._supportedAuth.push('PLAIN');\n    } // Detect if the server supports LOGIN auth\n\n\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n      this._supportedAuth.push('LOGIN');\n    } // Detect if the server supports CRAM-MD5 auth\n\n\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n      this._supportedAuth.push('CRAM-MD5');\n    } // Detect if the server supports XOAUTH2 auth\n\n\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n      this._supportedAuth.push('XOAUTH2');\n    } // Detect if the server supports SIZE extensions (and the max allowed size)\n\n\n    if (match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im)) {\n      this._supportedExtensions.push('SIZE');\n\n      this._maxAllowedSize = Number(match[1]) || 0;\n    }\n\n    this.emit('connect');\n  }\n  /**\n   * Handles server response for HELO command. If it yielded in\n   * error, emit 'error', otherwise move into the authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionHELO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n\n      return;\n    } // assume that authentication is enabled (most probably is not though)\n\n\n    this.allowsAuth = true;\n    this.emit('connect');\n  }\n  /**\n   * Handles server response for STARTTLS command. If there's an error\n   * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n   * succeedes restart the EHLO\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionSTARTTLS(str) {\n    if (str.charAt(0) !== '2') {\n      if (this.options.opportunisticTLS) {\n        this.logger.info({\n          tnx: 'smtp'\n        }, 'Failed STARTTLS upgrade, continuing unencrypted');\n        return this.emit('connect');\n      }\n\n      this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n\n      return;\n    }\n\n    this._upgradeConnection((err, secured) => {\n      if (err) {\n        this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n\n        return;\n      }\n\n      this.logger.info({\n        tnx: 'smtp'\n      }, 'Connection upgraded with STARTTLS');\n\n      if (secured) {\n        // restart session\n        if (this.options.lmtp) {\n          this._responseActions.push(this._actionLHLO);\n\n          this._sendCommand('LHLO ' + this.name);\n        } else {\n          this._responseActions.push(this._actionEHLO);\n\n          this._sendCommand('EHLO ' + this.name);\n        }\n      } else {\n        this.emit('connect');\n      }\n    });\n  }\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n   * response needs to be base64 encoded username. We do not need\n   * exact match but settle with 334 response in general as some\n   * hosts invalidly use a longer message than VXNlcm5hbWU6\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_LOGIN_USER(str, callback) {\n    if (!/^334[ -]/.test(str)) {\n      // expecting '334 VXNlcm5hbWU6'\n      callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n      return;\n    }\n\n    this._responseActions.push(str => {\n      this._actionAUTH_LOGIN_PASS(str, callback);\n    });\n\n    this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n  }\n  /**\n   * Handle the response for AUTH CRAM-MD5 command. We are expecting\n   * '334 <challenge string>'. Data to be sent as response needs to be\n   * base64 decoded challenge string, MD5 hashed using the password as\n   * a HMAC key, prefixed by the username and a space, and finally all\n   * base64 encoded again.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_CRAM_MD5(str, callback) {\n    let challengeMatch = str.match(/^334\\s+(.+)$/);\n    let challengeString = '';\n\n    if (!challengeMatch) {\n      return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    } else {\n      challengeString = challengeMatch[1];\n    } // Decode from base64\n\n\n    let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n        hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n    hmacMD5.update(base64decoded);\n    let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n\n    this._responseActions.push(str => {\n      this._actionAUTH_CRAM_MD5_PASS(str, callback);\n    });\n\n    this._sendCommand(Buffer.from(prepended).toString('base64'), // hidden hash for logs\n    Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64'));\n  }\n  /**\n   * Handles the response to CRAM-MD5 authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_CRAM_MD5_PASS(str, callback) {\n    if (!str.match(/^235\\s+/)) {\n      return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    }\n\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n   * response needs to be base64 encoded password.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_LOGIN_PASS(str, callback) {\n    if (!/^334[ -]/.test(str)) {\n      // expecting '334 UGFzc3dvcmQ6'\n      return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n    }\n\n    this._responseActions.push(str => {\n      this._actionAUTHComplete(str, callback);\n    });\n\n    this._sendCommand(Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'), // Hidden pass for logs\n    Buffer.from('/* secret */', 'utf-8').toString('base64'));\n  }\n  /**\n   * Handles the response for authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTHComplete(str, isRetry, callback) {\n    if (!callback && typeof isRetry === 'function') {\n      callback = isRetry;\n      isRetry = false;\n    }\n\n    if (str.substr(0, 3) === '334') {\n      this._responseActions.push(str => {\n        if (isRetry || this._authMethod !== 'XOAUTH2') {\n          this._actionAUTHComplete(str, true, callback);\n        } else {\n          // fetch a new OAuth2 access token\n          setImmediate(() => this._handleXOauth2Token(true, callback));\n        }\n      });\n\n      this._sendCommand('');\n\n      return;\n    }\n\n    if (str.charAt(0) !== '2') {\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authfail',\n        method: this._authMethod\n      }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n      return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n    }\n\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n  /**\n   * Handle response for a MAIL FROM: command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionMAIL(str, callback) {\n    let message, curRecipient;\n\n    if (Number(str.charAt(0)) !== 2) {\n      if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Mail command failed';\n      }\n\n      return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n    }\n\n    if (!this._envelope.rcptQueue.length) {\n      return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n    } else {\n      this._recipientQueue = [];\n\n      if (this._supportedExtensions.includes('PIPELINING')) {\n        while (this._envelope.rcptQueue.length) {\n          curRecipient = this._envelope.rcptQueue.shift();\n\n          this._recipientQueue.push(curRecipient);\n\n          this._responseActions.push(str => {\n            this._actionRCPT(str, callback);\n          });\n\n          this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n      } else {\n        curRecipient = this._envelope.rcptQueue.shift();\n\n        this._recipientQueue.push(curRecipient);\n\n        this._responseActions.push(str => {\n          this._actionRCPT(str, callback);\n        });\n\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n      }\n    }\n  }\n  /**\n   * Handle response for a RCPT TO: command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionRCPT(str, callback) {\n    let message,\n        err,\n        curRecipient = this._recipientQueue.shift();\n\n    if (Number(str.charAt(0)) !== 2) {\n      // this is a soft error\n      if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Recipient command failed';\n      }\n\n      this._envelope.rejected.push(curRecipient); // store error for the failed recipient\n\n\n      err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n      err.recipient = curRecipient;\n\n      this._envelope.rejectedErrors.push(err);\n    } else {\n      this._envelope.accepted.push(curRecipient);\n    }\n\n    if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n      if (this._envelope.rejected.length < this._envelope.to.length) {\n        this._responseActions.push(str => {\n          this._actionDATA(str, callback);\n        });\n\n        this._sendCommand('DATA');\n      } else {\n        err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n        err.rejected = this._envelope.rejected;\n        err.rejectedErrors = this._envelope.rejectedErrors;\n        return callback(err);\n      }\n    } else if (this._envelope.rcptQueue.length) {\n      curRecipient = this._envelope.rcptQueue.shift();\n\n      this._recipientQueue.push(curRecipient);\n\n      this._responseActions.push(str => {\n        this._actionRCPT(str, callback);\n      });\n\n      this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n    }\n  }\n  /**\n   * Handle response for a DATA command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionDATA(str, callback) {\n    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n    if (!/^[23]/.test(str)) {\n      return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n    }\n\n    let response = {\n      accepted: this._envelope.accepted,\n      rejected: this._envelope.rejected\n    };\n\n    if (this._envelope.rejectedErrors.length) {\n      response.rejectedErrors = this._envelope.rejectedErrors;\n    }\n\n    callback(null, response);\n  }\n  /**\n   * Handle response for a DATA stream when using SMTP\n   * We expect a single response that defines if the sending succeeded or failed\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionSMTPStream(str, callback) {\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n    } else {\n      // Message sent succesfully\n      return callback(null, str);\n    }\n  }\n  /**\n   * Handle response for a DATA stream\n   * We expect a separate response for every recipient. All recipients can either\n   * succeed or fail separately\n   *\n   * @param {String} recipient The recipient this response applies to\n   * @param {Boolean} final Is this the final recipient?\n   * @param {String} str Message from the server\n   */\n\n\n  _actionLMTPStream(recipient, final, str, callback) {\n    let err;\n\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n      err.recipient = recipient;\n\n      this._envelope.rejected.push(recipient);\n\n      this._envelope.rejectedErrors.push(err);\n\n      for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n        if (this._envelope.accepted[i] === recipient) {\n          this._envelope.accepted.splice(i, 1);\n        }\n      }\n    }\n\n    if (final) {\n      return callback(null, str);\n    }\n  }\n\n  _handleXOauth2Token(isRetry, callback) {\n    this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n      if (err) {\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authfail',\n          method: this._authMethod\n        }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n        return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n      }\n\n      this._responseActions.push(str => {\n        this._actionAUTHComplete(str, isRetry, callback);\n      });\n\n      this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken), //  Hidden for logs\n      'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */'));\n    });\n  }\n  /**\n   *\n   * @param {string} command\n   * @private\n   */\n\n\n  _isDestroyedMessage(command) {\n    if (this._destroyed) {\n      return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n    }\n\n    if (this._socket) {\n      if (this._socket.destroyed) {\n        return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n      }\n\n      if (!this._socket.writable) {\n        return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n      }\n    }\n  }\n\n  _getHostname() {\n    // defaul hostname is machine hostname or [IP]\n    let defaultHostname;\n\n    try {\n      defaultHostname = os.hostname() || '';\n    } catch (err) {\n      // fails on windows 7\n      defaultHostname = 'localhost';\n    } // ignore if not FQDN\n\n\n    if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n      defaultHostname = '[127.0.0.1]';\n    } // IP should be enclosed in []\n\n\n    if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n      defaultHostname = '[' + defaultHostname + ']';\n    }\n\n    return defaultHostname;\n  }\n\n}\n\nmodule.exports = SMTPConnection;","map":{"version":3,"names":["packageInfo","require","EventEmitter","net","tls","os","crypto","DataStream","PassThrough","shared","CONNECTION_TIMEOUT","SOCKET_TIMEOUT","GREETING_TIMEOUT","DNS_TIMEOUT","SMTPConnection","constructor","options","id","randomBytes","toString","replace","stage","secureConnection","secure","alreadySecured","secured","port","Number","host","allowInternalNetworkInterfaces","name","_getHostname","logger","getLogger","component","sid","customAuth","Map","Object","keys","forEach","key","mapKey","trim","toUpperCase","set","version","authenticated","destroyed","_remainder","_responseQueue","lastServerResponse","_socket","_supportedAuth","allowsAuth","_envelope","_supportedExtensions","_maxAllowedSize","_responseActions","_recipientQueue","_greetingTimeout","_connectionTimeout","_destroyed","_closing","_onSocketData","chunk","_onData","_onSocketError","error","_onError","_onSocketClose","_onClose","_onSocketEnd","_onEnd","_onSocketTimeout","_onTimeout","connect","connectCallback","once","debug","tnx","isDestroyedMessage","_isDestroyedMessage","_formatError","opts","timeout","dnsTimeout","localAddress","setupConnectionHandlers","setTimeout","connectionTimeout","on","connection","setImmediate","_upgradeConnection","err","Error","message","_onConnect","socket","resolveHostname","resolved","source","cached","charAt","setKeepAlive","E","quit","_sendCommand","push","close","clearTimeout","closeMethod","_destroy","login","authData","callback","_auth","_authMethod","method","oauth2","credentials","user","pass","has","handler","get","lastResponse","returned","resolve","info","username","action","JSON","stringify","reject","handlerResponse","auth","extensions","concat","authMethods","maxAllowedSize","sendCommand","cmd","done","promise","Promise","callbackPromise","str","codes","match","data","command","response","status","code","text","substr","length","catch","then","_handleXOauth2Token","_actionAUTH_LOGIN_USER","_actionAUTHComplete","Buffer","from","_actionAUTH_CRAM_MD5","send","envelope","size","arguments","startTime","Date","now","_setEnvelope","envelopeTime","stream","_createSendStream","messageTime","messageSize","outByteCount","pipe","write","end","reset","localPort","remoteAddress","remotePort","removeListener","socketTimeout","_actionGreeting","greetingTimeout","resume","lines","split","lastline","pop","i","len","test","_processResponse","type","emit","prototype","call","responseCode","upgrading","includes","destroy","socketPlain","shift","transactionLog","logStr","args","useSmtpUtf8","address","to","map","rcptQueue","parse","rejected","rejectedErrors","accepted","dsn","_setDsnEnvelope","_actionMAIL","_usingSmtpUtf8","use8BitMime","_using8BitMime","ret","encodeXText","envid","join","params","return","notify","n","validNotify","invaliNotify","filter","orcpt","recipient","indexOf","_getDsnRcptToArgs","dataStream","logStream","lmtp","final","_actionLMTPStream","_actionSMTPStream","read","inByteCount","_actionLHLO","_actionEHLO","requireTLS","_actionHELO","ignoreTLS","_actionSTARTTLS","opportunisticTLS","_actionAUTH_LOGIN_PASS","challengeMatch","challengeString","base64decoded","hmacMD5","createHmac","update","prepended","digest","_actionAUTH_CRAM_MD5_PASS","isRetry","curRecipient","_actionRCPT","_actionDATA","splice","getToken","accessToken","buildXOAuth2Token","writable","defaultHostname","hostname","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/smtp-connection/index.js"],"sourcesContent":["'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname \n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        this.customAuth = new Map();\n        Object.keys(this.options.customAuth || {}).forEach(key => {\n            let mapKey = (key || '').toString().trim().toUpperCase();\n            if (!mapKey) {\n                return;\n            }\n            this.customAuth.set(mapKey, this.options.customAuth[key]);\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Set to true, if EHLO response includes \"AUTH\".\n         * If false then authentication is not tried\n         */\n        this.allowsAuth = false;\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n\n        /**\n         * Callbacks for socket's listeners\n         */\n        this._onSocketData = chunk => this._onData(chunk);\n        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n        this._onSocketClose = () => this._onClose();\n        this._onSocketEnd = () => this._onEnd();\n        this._onSocketTimeout = () => this._onTimeout();\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host,\n            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n            timeout: this.options.dnsTimeout || DNS_TIMEOUT\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        let setupConnectionHandlers = () => {\n            this._connectionTimeout = setTimeout(() => {\n                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n            this._socket.on('error', this._onSocketError);\n        };\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n            return;\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket.connect(this.port, this.host, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = tls.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else {\n            // connect using plaintext\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = net.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n        // Select SASL authentication method\n        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if (this._auth.user && this._auth.pass) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass,\n                    options: this._auth.options\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        if (this.customAuth.has(this._authMethod)) {\n            let handler = this.customAuth.get(this._authMethod);\n            let lastResponse;\n            let returned = false;\n\n            let resolve = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authenticated',\n                        method: this._authMethod\n                    },\n                    'User %s authenticated',\n                    JSON.stringify(this._auth.user)\n                );\n                this.authenticated = true;\n                callback(null, true);\n            };\n\n            let reject = err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n            };\n\n            let handlerResponse = handler({\n                auth: this._auth,\n                method: this._authMethod,\n\n                extensions: [].concat(this._supportedExtensions),\n                authMethods: [].concat(this._supportedAuth),\n                maxAllowedSize: this._maxAllowedSize || false,\n\n                sendCommand: (cmd, done) => {\n                    let promise;\n\n                    if (!done) {\n                        promise = new Promise((resolve, reject) => {\n                            done = shared.callbackPromise(resolve, reject);\n                        });\n                    }\n\n                    this._responseActions.push(str => {\n                        lastResponse = str;\n\n                        let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n                        let data = {\n                            command: cmd,\n                            response: str\n                        };\n                        if (codes) {\n                            data.status = Number(codes[1]) || 0;\n                            if (codes[2]) {\n                                data.code = codes[2];\n                            }\n                            data.text = str.substr(codes[0].length);\n                        } else {\n                            data.text = str;\n                            data.status = 0; // just in case we need to perform numeric comparisons\n                        }\n                        done(null, data);\n                    });\n                    setImmediate(() => this._sendCommand(cmd));\n\n                    return promise;\n                },\n\n                resolve,\n                reject\n            });\n\n            if (handlerResponse && typeof handlerResponse.catch === 'function') {\n                // a promise was returned\n                handlerResponse.then(resolve).catch(reject);\n            }\n\n            return;\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64'),\n                    // log entry without passwords\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                '/* secret */',\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeListener('data', this._onSocketData);\n        this._socket.removeListener('timeout', this._onSocketTimeout);\n        this._socket.removeListener('close', this._onSocketClose);\n        this._socket.removeListener('end', this._onSocketEnd);\n\n        this._socket.on('data', this._onSocketData);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                return;\n            }\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        if (this._socket && !this._socket.destroyed) {\n            this._socket.destroy();\n        }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        this.upgrading = true;\n        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n        try {\n            this._socket = tls.connect(opts, () => {\n                this.secure = true;\n                this.upgrading = false;\n                this._socket.on('data', this._onSocketData);\n\n                socketPlain.removeListener('close', this._onSocketClose);\n                socketPlain.removeListener('end', this._onSocketEnd);\n\n                return callback(null, true);\n            });\n        } catch (err) {\n            return callback(err);\n        }\n\n        this._socket.on('error', this._onSocketError);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse(true));\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse(true));\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     * @param {String} logStr Optional string to be used for logging instead of the actual string\n     */\n    _sendCommand(str, logStr) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (logStr || str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports AUTH\n        if (/[ -]AUTH\\b/i.test(str)) {\n            this.allowsAuth = true;\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        // assume that authentication is enabled (most probably is not though)\n        this.allowsAuth = true;\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmacMD5.update(base64decoded);\n\n        let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from(prepended).toString('base64'),\n            // hidden hash for logs\n            Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n            // Hidden pass for logs\n            Buffer.from('/* secret */', 'utf-8').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand(\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),\n                //  Hidden for logs\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */')\n            );\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname;\n        try {\n            defaultHostname = os.hostname() || '';\n        } catch (err) {\n            // fails on windows 7\n            defaultHostname = 'localhost';\n        }\n\n        // ignore if not FQDN\n        if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}