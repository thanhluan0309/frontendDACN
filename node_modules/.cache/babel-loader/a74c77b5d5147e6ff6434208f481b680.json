{"ast":null,"code":"/*!\n * ScrollToPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _window,\n    _docEl,\n    _body,\n    _toArray,\n    _config,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _max = function _max(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim;\n  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n},\n    _buildGetter = function _buildGetter(e, axis) {\n  //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\" + axis.toUpperCase() + \"Offset\";\n    } else {\n      e = _docEl[p] != null ? _docEl : _body;\n    }\n  }\n\n  return function () {\n    return e[p];\n  };\n},\n    _clean = function _clean(value, index, target, targets) {\n  _isFunction(value) && (value = value(index, target, targets));\n\n  if (typeof value !== \"object\") {\n    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n      x: value,\n      y: value\n    } : {\n      y: value\n    }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n  } else if (value.nodeType) {\n    return {\n      y: value,\n      x: value\n    };\n  } else {\n    var result = {},\n        p;\n\n    for (p in value) {\n      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n    }\n\n    return result;\n  }\n},\n    _getOffset = function _getOffset(element, container) {\n  element = _toArray(element)[0];\n\n  if (!element || !element.getBoundingClientRect) {\n    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n  } : container.getBoundingClientRect(),\n      offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n\n  if (!isRoot && container) {\n    //only add the current scroll position if it's not the window/body.\n    offsets.x += _buildGetter(container, \"x\")();\n    offsets.y += _buildGetter(container, \"y\")();\n  }\n\n  return offsets;\n},\n    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (_windowExists() && gsap && document.body) {\n    _window = window;\n    _body = document.body;\n    _docEl = document.documentElement;\n    _toArray = gsap.utils.toArray;\n    gsap.config({\n      autoKillThreshold: 7\n    });\n    _config = gsap.config();\n    _coreInitted = 1;\n  }\n};\n\nexport var ScrollToPlugin = {\n  version: \"3.11.2\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    var data = this,\n        snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n      scrollBehavior: \"auto\"\n    });\n\n    if (snapType && snapType !== \"none\") {\n      // disable scroll snapping to avoid strange behavior\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt,\n        target = data.target,\n        tween = data.tween,\n        autoKill = data.autoKill,\n        xPrev = data.xPrev,\n        yPrev = data.yPrev,\n        isWin = data.isWin,\n        snap = data.snap,\n        snapInline = data.snapInline,\n        x,\n        y,\n        yDif,\n        xDif,\n        threshold;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n\n    if (data.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n\n    if (data.y < 0) {\n      data.y = 0;\n    }\n\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n\n      target.scrollLeft = x + 1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n  },\n  kill: function kill(property) {\n    var both = property === \"scrollTo\";\n\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\nexport { ScrollToPlugin as default };","map":{"version":3,"names":["gsap","_coreInitted","_window","_docEl","_body","_toArray","_config","_windowExists","window","_getGSAP","registerPlugin","_isString","value","_isFunction","_max","element","axis","dim","scroll","client","Math","max","_buildGetter","e","p","pageXOffset","toUpperCase","_clean","index","target","targets","charAt","x","y","nodeType","result","_getOffset","container","getBoundingClientRect","console","warn","rect","isRoot","cRect","top","clientTop","pageYOffset","scrollTop","left","clientLeft","scrollLeft","offsets","_parseVal","currentVal","offset","isNaN","parseFloat","substr","min","_initCore","document","body","documentElement","utils","toArray","config","autoKillThreshold","ScrollToPlugin","version","name","rawVars","register","core","init","tween","data","snapType","getProperty","isWin","vars","autoKill","getX","getY","xPrev","yPrev","set","scrollBehavior","snap","snapInline","style","scrollSnapType","add","offsetX","_props","push","skipX","offsetY","skipY","render","ratio","pt","_pt","yDif","xDif","threshold","r","d","_next","kill","onAutoKill","apply","onAutoKillParams","scrollTo","removeProperty","property","both","getOffset","buildGetter","default"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/gsap/ScrollToPlugin.js"],"sourcesContent":["/*!\n * ScrollToPlugin 3.11.2\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _window,\n    _docEl,\n    _body,\n    _toArray,\n    _config,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _max = function _max(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim;\n  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n},\n    _buildGetter = function _buildGetter(e, axis) {\n  //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\" + axis.toUpperCase() + \"Offset\";\n    } else {\n      e = _docEl[p] != null ? _docEl : _body;\n    }\n  }\n\n  return function () {\n    return e[p];\n  };\n},\n    _clean = function _clean(value, index, target, targets) {\n  _isFunction(value) && (value = value(index, target, targets));\n\n  if (typeof value !== \"object\") {\n    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n      x: value,\n      y: value\n    } : {\n      y: value\n    }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n  } else if (value.nodeType) {\n    return {\n      y: value,\n      x: value\n    };\n  } else {\n    var result = {},\n        p;\n\n    for (p in value) {\n      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n    }\n\n    return result;\n  }\n},\n    _getOffset = function _getOffset(element, container) {\n  element = _toArray(element)[0];\n\n  if (!element || !element.getBoundingClientRect) {\n    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n  } : container.getBoundingClientRect(),\n      offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n\n  if (!isRoot && container) {\n    //only add the current scroll position if it's not the window/body.\n    offsets.x += _buildGetter(container, \"x\")();\n    offsets.y += _buildGetter(container, \"y\")();\n  }\n\n  return offsets;\n},\n    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (_windowExists() && gsap && document.body) {\n    _window = window;\n    _body = document.body;\n    _docEl = document.documentElement;\n    _toArray = gsap.utils.toArray;\n    gsap.config({\n      autoKillThreshold: 7\n    });\n    _config = gsap.config();\n    _coreInitted = 1;\n  }\n};\n\nexport var ScrollToPlugin = {\n  version: \"3.11.2\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    var data = this,\n        snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n      scrollBehavior: \"auto\"\n    });\n\n    if (snapType && snapType !== \"none\") {\n      // disable scroll snapping to avoid strange behavior\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt,\n        target = data.target,\n        tween = data.tween,\n        autoKill = data.autoKill,\n        xPrev = data.xPrev,\n        yPrev = data.yPrev,\n        isWin = data.isWin,\n        snap = data.snap,\n        snapInline = data.snapInline,\n        x,\n        y,\n        yDif,\n        xDif,\n        threshold;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n\n    if (data.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n\n    if (data.y < 0) {\n      data.y = 0;\n    }\n\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n\n      target.scrollLeft = x + 1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n  },\n  kill: function kill(property) {\n    var both = property === \"scrollTo\";\n\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\nexport { ScrollToPlugin as default };"],"mappings":"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"},"metadata":{},"sourceType":"module"}