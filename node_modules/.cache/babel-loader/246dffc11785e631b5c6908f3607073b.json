{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst PoolResource = require('./pool-resource');\n\nconst SMTPConnection = require('../smtp-connection');\n\nconst wellKnown = require('../well-known');\n\nconst shared = require('../shared');\n\nconst packageData = require('../../package.json');\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\n\n\nclass SMTPPool extends EventEmitter {\n  constructor(options) {\n    super();\n    options = options || {};\n\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n\n    let urlData;\n    let service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n      this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n\n    this.options = shared.assign(false, // create new object\n    options, // regular options\n    urlData, // url options\n    service && wellKnown(service) // wellknown options\n    );\n    this.options.maxConnections = this.options.maxConnections || 5;\n    this.options.maxMessages = this.options.maxMessages || 100;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-pool'\n    }); // temporary object\n\n    let connection = new SMTPConnection(this.options);\n    this.name = 'SMTP (pool)';\n    this.version = packageData.version + '[client:' + connection.version + ']';\n    this._rateLimit = {\n      counter: 0,\n      timeout: null,\n      waiting: [],\n      checkpoint: false,\n      delta: Number(this.options.rateDelta) || 1000,\n      limit: Number(this.options.rateLimit) || 0\n    };\n    this._closed = false;\n    this._queue = [];\n    this._connections = [];\n    this._connectionCounter = 0;\n    this.idling = true;\n    setImmediate(() => {\n      if (this.idling) {\n        this.emit('idle');\n      }\n    });\n  }\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n\n\n  getSocket(options, callback) {\n    // return immediatelly\n    return setImmediate(() => callback(null, false));\n  }\n  /**\n   * Queues an e-mail to be sent using the selected settings\n   *\n   * @param {Object} mail Mail object\n   * @param {Function} callback Callback function\n   */\n\n\n  send(mail, callback) {\n    if (this._closed) {\n      return false;\n    }\n\n    this._queue.push({\n      mail,\n      requeueAttempts: 0,\n      callback\n    });\n\n    if (this.idling && this._queue.length >= this.options.maxConnections) {\n      this.idling = false;\n    }\n\n    setImmediate(() => this._processMessages());\n    return true;\n  }\n  /**\n   * Closes all connections in the pool. If there is a message being sent, the connection\n   * is closed later\n   */\n\n\n  close() {\n    let connection;\n    let len = this._connections.length;\n    this._closed = true; // clear rate limit timer if it exists\n\n    clearTimeout(this._rateLimit.timeout);\n\n    if (!len && !this._queue.length) {\n      return;\n    } // remove all available connections\n\n\n    for (let i = len - 1; i >= 0; i--) {\n      if (this._connections[i] && this._connections[i].available) {\n        connection = this._connections[i];\n        connection.close();\n        this.logger.info({\n          tnx: 'connection',\n          cid: connection.id,\n          action: 'removed'\n        }, 'Connection #%s removed', connection.id);\n      }\n    }\n\n    if (len && !this._connections.length) {\n      this.logger.debug({\n        tnx: 'connection'\n      }, 'All connections removed');\n    }\n\n    if (!this._queue.length) {\n      return;\n    } // make sure that entire queue would be cleaned\n\n\n    let invokeCallbacks = () => {\n      if (!this._queue.length) {\n        this.logger.debug({\n          tnx: 'connection'\n        }, 'Pending queue entries cleared');\n        return;\n      }\n\n      let entry = this._queue.shift();\n\n      if (entry && typeof entry.callback === 'function') {\n        try {\n          entry.callback(new Error('Connection pool was closed'));\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n      }\n\n      setImmediate(invokeCallbacks);\n    };\n\n    setImmediate(invokeCallbacks);\n  }\n  /**\n   * Check the queue and available connections. If there is a message to be sent and there is\n   * an available connection, then use this connection to send the mail\n   */\n\n\n  _processMessages() {\n    let connection;\n    let i, len; // do nothing if already closed\n\n    if (this._closed) {\n      return;\n    } // do nothing if queue is empty\n\n\n    if (!this._queue.length) {\n      if (!this.idling) {\n        // no pending jobs\n        this.idling = true;\n        this.emit('idle');\n      }\n\n      return;\n    } // find first available connection\n\n\n    for (i = 0, len = this._connections.length; i < len; i++) {\n      if (this._connections[i].available) {\n        connection = this._connections[i];\n        break;\n      }\n    }\n\n    if (!connection && this._connections.length < this.options.maxConnections) {\n      connection = this._createConnection();\n    }\n\n    if (!connection) {\n      // no more free connection slots available\n      this.idling = false;\n      return;\n    } // check if there is free space in the processing queue\n\n\n    if (!this.idling && this._queue.length < this.options.maxConnections) {\n      this.idling = true;\n      this.emit('idle');\n    }\n\n    let entry = connection.queueEntry = this._queue.shift();\n\n    entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n    connection.available = false;\n    this.logger.debug({\n      tnx: 'pool',\n      cid: connection.id,\n      messageId: entry.messageId,\n      action: 'assign'\n    }, 'Assigned message <%s> to #%s (%s)', entry.messageId, connection.id, connection.messages + 1);\n\n    if (this._rateLimit.limit) {\n      this._rateLimit.counter++;\n\n      if (!this._rateLimit.checkpoint) {\n        this._rateLimit.checkpoint = Date.now();\n      }\n    }\n\n    connection.send(entry.mail, (err, info) => {\n      // only process callback if current handler is not changed\n      if (entry === connection.queueEntry) {\n        try {\n          entry.callback(err, info);\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n\n        connection.queueEntry = false;\n      }\n    });\n  }\n  /**\n   * Creates a new pool resource\n   */\n\n\n  _createConnection() {\n    let connection = new PoolResource(this);\n    connection.id = ++this._connectionCounter;\n    this.logger.info({\n      tnx: 'pool',\n      cid: connection.id,\n      action: 'conection'\n    }, 'Created new pool resource #%s', connection.id); // resource comes available\n\n    connection.on('available', () => {\n      this.logger.debug({\n        tnx: 'connection',\n        cid: connection.id,\n        action: 'available'\n      }, 'Connection #%s became available', connection.id);\n\n      if (this._closed) {\n        // if already closed run close() that will remove this connections from connections list\n        this.close();\n      } else {\n        // check if there's anything else to send\n        this._processMessages();\n      }\n    }); // resource is terminated with an error\n\n    connection.once('error', err => {\n      if (err.code !== 'EMAXLIMIT') {\n        this.logger.error({\n          err,\n          tnx: 'pool',\n          cid: connection.id\n        }, 'Pool Error for #%s: %s', connection.id, err.message);\n      } else {\n        this.logger.debug({\n          tnx: 'pool',\n          cid: connection.id,\n          action: 'maxlimit'\n        }, 'Max messages limit exchausted for #%s', connection.id);\n      }\n\n      if (connection.queueEntry) {\n        try {\n          connection.queueEntry.callback(err);\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n\n        connection.queueEntry = false;\n      } // remove the erroneus connection from connections list\n\n\n      this._removeConnection(connection);\n\n      this._continueProcessing();\n    });\n    connection.once('close', () => {\n      this.logger.info({\n        tnx: 'connection',\n        cid: connection.id,\n        action: 'closed'\n      }, 'Connection #%s was closed', connection.id);\n\n      this._removeConnection(connection);\n\n      if (connection.queueEntry) {\n        // If the connection closed when sending, add the message to the queue again\n        // if max number of requeues is not reached yet\n        // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n        // in the next event loop\n        setTimeout(() => {\n          if (connection.queueEntry) {\n            if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n              this._requeueEntryOnConnectionClose(connection);\n            } else {\n              this._failDeliveryOnConnectionClose(connection);\n            }\n          }\n\n          this._continueProcessing();\n        }, 50);\n      } else {\n        this._continueProcessing();\n      }\n    });\n\n    this._connections.push(connection);\n\n    return connection;\n  }\n\n  _shouldRequeuOnConnectionClose(queueEntry) {\n    if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n      return true;\n    }\n\n    return queueEntry.requeueAttempts < this.options.maxRequeues;\n  }\n\n  _failDeliveryOnConnectionClose(connection) {\n    if (connection.queueEntry && connection.queueEntry.callback) {\n      try {\n        connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n      } catch (E) {\n        this.logger.error({\n          err: E,\n          tnx: 'callback',\n          messageId: connection.queueEntry.messageId,\n          cid: connection.id\n        }, 'Callback error for #%s: %s', connection.id, E.message);\n      }\n\n      connection.queueEntry = false;\n    }\n  }\n\n  _requeueEntryOnConnectionClose(connection) {\n    connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n    this.logger.debug({\n      tnx: 'pool',\n      cid: connection.id,\n      messageId: connection.queueEntry.messageId,\n      action: 'requeue'\n    }, 'Re-queued message <%s> for #%s. Attempt: #%s', connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);\n\n    this._queue.unshift(connection.queueEntry);\n\n    connection.queueEntry = false;\n  }\n  /**\n   * Continue to process message if the pool hasn't closed\n   */\n\n\n  _continueProcessing() {\n    if (this._closed) {\n      this.close();\n    } else {\n      setTimeout(() => this._processMessages(), 100);\n    }\n  }\n  /**\n   * Remove resource from pool\n   *\n   * @param {Object} connection The PoolResource to remove\n   */\n\n\n  _removeConnection(connection) {\n    let index = this._connections.indexOf(connection);\n\n    if (index !== -1) {\n      this._connections.splice(index, 1);\n    }\n  }\n  /**\n   * Checks if connections have hit current rate limit and if so, queues the availability callback\n   *\n   * @param {Function} callback Callback function to run once rate limiter has been cleared\n   */\n\n\n  _checkRateLimit(callback) {\n    if (!this._rateLimit.limit) {\n      return callback();\n    }\n\n    let now = Date.now();\n\n    if (this._rateLimit.counter < this._rateLimit.limit) {\n      return callback();\n    }\n\n    this._rateLimit.waiting.push(callback);\n\n    if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n      return this._clearRateLimit();\n    } else if (!this._rateLimit.timeout) {\n      this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n      this._rateLimit.checkpoint = now;\n    }\n  }\n  /**\n   * Clears current rate limit limitation and runs paused callback\n   */\n\n\n  _clearRateLimit() {\n    clearTimeout(this._rateLimit.timeout);\n    this._rateLimit.timeout = null;\n    this._rateLimit.counter = 0;\n    this._rateLimit.checkpoint = false; // resume all paused connections\n\n    while (this._rateLimit.waiting.length) {\n      let cb = this._rateLimit.waiting.shift();\n\n      setImmediate(cb);\n    }\n  }\n  /**\n   * Returns true if there are free slots in the queue\n   */\n\n\n  isIdle() {\n    return this.idling;\n  }\n  /**\n   * Verifies SMTP configuration\n   *\n   * @param {Function} callback Callback function\n   */\n\n\n  verify(callback) {\n    let promise;\n\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n\n    let auth = new PoolResource(this).auth;\n    this.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let options = this.options;\n\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n        options = shared.assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n\n      let connection = new SMTPConnection(options);\n      let returned = false;\n      connection.once('error', err => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        connection.close();\n        return callback(err);\n      });\n      connection.once('end', () => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        return callback(new Error('Connection closed'));\n      });\n\n      let finalize = () => {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        connection.quit();\n        return callback(null, true);\n      };\n\n      connection.connect(() => {\n        if (returned) {\n          return;\n        }\n\n        if (auth && (connection.allowsAuth || options.forceAuth)) {\n          connection.login(auth, err => {\n            if (returned) {\n              return;\n            }\n\n            if (err) {\n              returned = true;\n              connection.close();\n              return callback(err);\n            }\n\n            finalize();\n          });\n        } else if (!auth && connection.allowsAuth && options.forceAuth) {\n          let err = new Error('Authentication info was not provided');\n          err.code = 'NoAuth';\n          returned = true;\n          connection.close();\n          return callback(err);\n        } else {\n          finalize();\n        }\n      });\n    });\n    return promise;\n  }\n\n} // expose to the world\n\n\nmodule.exports = SMTPPool;","map":{"version":3,"names":["EventEmitter","require","PoolResource","SMTPConnection","wellKnown","shared","packageData","SMTPPool","constructor","options","url","urlData","service","getSocket","parseConnectionUrl","assign","maxConnections","maxMessages","logger","getLogger","component","connection","name","version","_rateLimit","counter","timeout","waiting","checkpoint","delta","Number","rateDelta","limit","rateLimit","_closed","_queue","_connections","_connectionCounter","idling","setImmediate","emit","callback","send","mail","push","requeueAttempts","length","_processMessages","close","len","clearTimeout","i","available","info","tnx","cid","id","action","debug","invokeCallbacks","entry","shift","Error","E","error","err","message","_createConnection","queueEntry","messageId","getHeader","replace","messages","Date","now","on","once","code","_removeConnection","_continueProcessing","setTimeout","_shouldRequeuOnConnectionClose","_requeueEntryOnConnectionClose","_failDeliveryOnConnectionClose","maxRequeues","undefined","unshift","index","indexOf","splice","_checkRateLimit","_clearRateLimit","cb","isIdle","verify","promise","Promise","resolve","reject","callbackPromise","auth","socketOptions","remoteAddress","remotePort","destHost","host","destPort","port","Object","keys","forEach","key","returned","finalize","quit","connect","allowsAuth","forceAuth","login","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/smtp-pool/index.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst PoolResource = require('./pool-resource');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\nclass SMTPPool extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.options.maxConnections = this.options.maxConnections || 5;\n        this.options.maxMessages = this.options.maxMessages || 100;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-pool'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP (pool)';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        this._rateLimit = {\n            counter: 0,\n            timeout: null,\n            waiting: [],\n            checkpoint: false,\n            delta: Number(this.options.rateDelta) || 1000,\n            limit: Number(this.options.rateLimit) || 0\n        };\n        this._closed = false;\n        this._queue = [];\n        this._connections = [];\n        this._connectionCounter = 0;\n\n        this.idling = true;\n\n        setImmediate(() => {\n            if (this.idling) {\n                this.emit('idle');\n            }\n        });\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    /**\n     * Queues an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        if (this._closed) {\n            return false;\n        }\n\n        this._queue.push({\n            mail,\n            requeueAttempts: 0,\n            callback\n        });\n\n        if (this.idling && this._queue.length >= this.options.maxConnections) {\n            this.idling = false;\n        }\n\n        setImmediate(() => this._processMessages());\n\n        return true;\n    }\n\n    /**\n     * Closes all connections in the pool. If there is a message being sent, the connection\n     * is closed later\n     */\n    close() {\n        let connection;\n        let len = this._connections.length;\n        this._closed = true;\n\n        // clear rate limit timer if it exists\n        clearTimeout(this._rateLimit.timeout);\n\n        if (!len && !this._queue.length) {\n            return;\n        }\n\n        // remove all available connections\n        for (let i = len - 1; i >= 0; i--) {\n            if (this._connections[i] && this._connections[i].available) {\n                connection = this._connections[i];\n                connection.close();\n                this.logger.info(\n                    {\n                        tnx: 'connection',\n                        cid: connection.id,\n                        action: 'removed'\n                    },\n                    'Connection #%s removed',\n                    connection.id\n                );\n            }\n        }\n\n        if (len && !this._connections.length) {\n            this.logger.debug(\n                {\n                    tnx: 'connection'\n                },\n                'All connections removed'\n            );\n        }\n\n        if (!this._queue.length) {\n            return;\n        }\n\n        // make sure that entire queue would be cleaned\n        let invokeCallbacks = () => {\n            if (!this._queue.length) {\n                this.logger.debug(\n                    {\n                        tnx: 'connection'\n                    },\n                    'Pending queue entries cleared'\n                );\n                return;\n            }\n            let entry = this._queue.shift();\n            if (entry && typeof entry.callback === 'function') {\n                try {\n                    entry.callback(new Error('Connection pool was closed'));\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n            }\n            setImmediate(invokeCallbacks);\n        };\n        setImmediate(invokeCallbacks);\n    }\n\n    /**\n     * Check the queue and available connections. If there is a message to be sent and there is\n     * an available connection, then use this connection to send the mail\n     */\n    _processMessages() {\n        let connection;\n        let i, len;\n\n        // do nothing if already closed\n        if (this._closed) {\n            return;\n        }\n\n        // do nothing if queue is empty\n        if (!this._queue.length) {\n            if (!this.idling) {\n                // no pending jobs\n                this.idling = true;\n                this.emit('idle');\n            }\n            return;\n        }\n\n        // find first available connection\n        for (i = 0, len = this._connections.length; i < len; i++) {\n            if (this._connections[i].available) {\n                connection = this._connections[i];\n                break;\n            }\n        }\n\n        if (!connection && this._connections.length < this.options.maxConnections) {\n            connection = this._createConnection();\n        }\n\n        if (!connection) {\n            // no more free connection slots available\n            this.idling = false;\n            return;\n        }\n\n        // check if there is free space in the processing queue\n        if (!this.idling && this._queue.length < this.options.maxConnections) {\n            this.idling = true;\n            this.emit('idle');\n        }\n\n        let entry = (connection.queueEntry = this._queue.shift());\n        entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n\n        connection.available = false;\n\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: entry.messageId,\n                action: 'assign'\n            },\n            'Assigned message <%s> to #%s (%s)',\n            entry.messageId,\n            connection.id,\n            connection.messages + 1\n        );\n\n        if (this._rateLimit.limit) {\n            this._rateLimit.counter++;\n            if (!this._rateLimit.checkpoint) {\n                this._rateLimit.checkpoint = Date.now();\n            }\n        }\n\n        connection.send(entry.mail, (err, info) => {\n            // only process callback if current handler is not changed\n            if (entry === connection.queueEntry) {\n                try {\n                    entry.callback(err, info);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n        });\n    }\n\n    /**\n     * Creates a new pool resource\n     */\n    _createConnection() {\n        let connection = new PoolResource(this);\n\n        connection.id = ++this._connectionCounter;\n\n        this.logger.info(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                action: 'conection'\n            },\n            'Created new pool resource #%s',\n            connection.id\n        );\n\n        // resource comes available\n        connection.on('available', () => {\n            this.logger.debug(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'available'\n                },\n                'Connection #%s became available',\n                connection.id\n            );\n\n            if (this._closed) {\n                // if already closed run close() that will remove this connections from connections list\n                this.close();\n            } else {\n                // check if there's anything else to send\n                this._processMessages();\n            }\n        });\n\n        // resource is terminated with an error\n        connection.once('error', err => {\n            if (err.code !== 'EMAXLIMIT') {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'pool',\n                        cid: connection.id\n                    },\n                    'Pool Error for #%s: %s',\n                    connection.id,\n                    err.message\n                );\n            } else {\n                this.logger.debug(\n                    {\n                        tnx: 'pool',\n                        cid: connection.id,\n                        action: 'maxlimit'\n                    },\n                    'Max messages limit exchausted for #%s',\n                    connection.id\n                );\n            }\n\n            if (connection.queueEntry) {\n                try {\n                    connection.queueEntry.callback(err);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n\n            // remove the erroneus connection from connections list\n            this._removeConnection(connection);\n\n            this._continueProcessing();\n        });\n\n        connection.once('close', () => {\n            this.logger.info(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'closed'\n                },\n                'Connection #%s was closed',\n                connection.id\n            );\n\n            this._removeConnection(connection);\n\n            if (connection.queueEntry) {\n                // If the connection closed when sending, add the message to the queue again\n                // if max number of requeues is not reached yet\n                // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n                // in the next event loop\n                setTimeout(() => {\n                    if (connection.queueEntry) {\n                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n                            this._requeueEntryOnConnectionClose(connection);\n                        } else {\n                            this._failDeliveryOnConnectionClose(connection);\n                        }\n                    }\n                    this._continueProcessing();\n                }, 50);\n            } else {\n                this._continueProcessing();\n            }\n        });\n\n        this._connections.push(connection);\n\n        return connection;\n    }\n\n    _shouldRequeuOnConnectionClose(queueEntry) {\n        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n            return true;\n        }\n\n        return queueEntry.requeueAttempts < this.options.maxRequeues;\n    }\n\n    _failDeliveryOnConnectionClose(connection) {\n        if (connection.queueEntry && connection.queueEntry.callback) {\n            try {\n                connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n            } catch (E) {\n                this.logger.error(\n                    {\n                        err: E,\n                        tnx: 'callback',\n                        messageId: connection.queueEntry.messageId,\n                        cid: connection.id\n                    },\n                    'Callback error for #%s: %s',\n                    connection.id,\n                    E.message\n                );\n            }\n            connection.queueEntry = false;\n        }\n    }\n\n    _requeueEntryOnConnectionClose(connection) {\n        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: connection.queueEntry.messageId,\n                action: 'requeue'\n            },\n            'Re-queued message <%s> for #%s. Attempt: #%s',\n            connection.queueEntry.messageId,\n            connection.id,\n            connection.queueEntry.requeueAttempts\n        );\n        this._queue.unshift(connection.queueEntry);\n        connection.queueEntry = false;\n    }\n\n    /**\n     * Continue to process message if the pool hasn't closed\n     */\n    _continueProcessing() {\n        if (this._closed) {\n            this.close();\n        } else {\n            setTimeout(() => this._processMessages(), 100);\n        }\n    }\n\n    /**\n     * Remove resource from pool\n     *\n     * @param {Object} connection The PoolResource to remove\n     */\n    _removeConnection(connection) {\n        let index = this._connections.indexOf(connection);\n\n        if (index !== -1) {\n            this._connections.splice(index, 1);\n        }\n    }\n\n    /**\n     * Checks if connections have hit current rate limit and if so, queues the availability callback\n     *\n     * @param {Function} callback Callback function to run once rate limiter has been cleared\n     */\n    _checkRateLimit(callback) {\n        if (!this._rateLimit.limit) {\n            return callback();\n        }\n\n        let now = Date.now();\n\n        if (this._rateLimit.counter < this._rateLimit.limit) {\n            return callback();\n        }\n\n        this._rateLimit.waiting.push(callback);\n\n        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n            return this._clearRateLimit();\n        } else if (!this._rateLimit.timeout) {\n            this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n            this._rateLimit.checkpoint = now;\n        }\n    }\n\n    /**\n     * Clears current rate limit limitation and runs paused callback\n     */\n    _clearRateLimit() {\n        clearTimeout(this._rateLimit.timeout);\n        this._rateLimit.timeout = null;\n        this._rateLimit.counter = 0;\n        this._rateLimit.checkpoint = false;\n\n        // resume all paused connections\n        while (this._rateLimit.waiting.length) {\n            let cb = this._rateLimit.waiting.shift();\n            setImmediate(cb);\n        }\n    }\n\n    /**\n     * Returns true if there are free slots in the queue\n     */\n    isIdle() {\n        return this.idling;\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let auth = new PoolResource(this).auth;\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else if (!auth && connection.allowsAuth && options.forceAuth) {\n                    let err = new Error('Authentication info was not provided');\n                    err.code = 'NoAuth';\n\n                    returned = true;\n                    connection.close();\n                    return callback(err);\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPPool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}