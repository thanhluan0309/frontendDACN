{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst Transform = stream.Transform;\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\n\nclass DataStream extends Transform {\n  constructor(options) {\n    super(options); // init Transform\n\n    this.options = options || {};\n    this._curLine = '';\n    this.inByteCount = 0;\n    this.outByteCount = 0;\n    this.lastByte = false;\n  }\n  /**\n   * Escapes dots\n   */\n\n\n  _transform(chunk, encoding, done) {\n    let chunks = [];\n    let chunklen = 0;\n    let i,\n        len,\n        lastPos = 0;\n    let buf;\n\n    if (!chunk || !chunk.length) {\n      return done();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk);\n    }\n\n    this.inByteCount += chunk.length;\n\n    for (i = 0, len = chunk.length; i < len; i++) {\n      if (chunk[i] === 0x2e) {\n        // .\n        if (i && chunk[i - 1] === 0x0a || !i && (!this.lastByte || this.lastByte === 0x0a)) {\n          buf = chunk.slice(lastPos, i + 1);\n          chunks.push(buf);\n          chunks.push(Buffer.from('.'));\n          chunklen += buf.length + 1;\n          lastPos = i + 1;\n        }\n      } else if (chunk[i] === 0x0a) {\n        // .\n        if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {\n          if (i > lastPos) {\n            buf = chunk.slice(lastPos, i);\n            chunks.push(buf);\n            chunklen += buf.length + 2;\n          } else {\n            chunklen += 2;\n          }\n\n          chunks.push(Buffer.from('\\r\\n'));\n          lastPos = i + 1;\n        }\n      }\n    }\n\n    if (chunklen) {\n      // add last piece\n      if (lastPos < chunk.length) {\n        buf = chunk.slice(lastPos);\n        chunks.push(buf);\n        chunklen += buf.length;\n      }\n\n      this.outByteCount += chunklen;\n      this.push(Buffer.concat(chunks, chunklen));\n    } else {\n      this.outByteCount += chunk.length;\n      this.push(chunk);\n    }\n\n    this.lastByte = chunk[chunk.length - 1];\n    done();\n  }\n  /**\n   * Finalizes the stream with a dot on a single line\n   */\n\n\n  _flush(done) {\n    let buf;\n\n    if (this.lastByte === 0x0a) {\n      buf = Buffer.from('.\\r\\n');\n    } else if (this.lastByte === 0x0d) {\n      buf = Buffer.from('\\n.\\r\\n');\n    } else {\n      buf = Buffer.from('\\r\\n.\\r\\n');\n    }\n\n    this.outByteCount += buf.length;\n    this.push(buf);\n    done();\n  }\n\n}\n\nmodule.exports = DataStream;","map":{"version":3,"names":["stream","require","Transform","DataStream","constructor","options","_curLine","inByteCount","outByteCount","lastByte","_transform","chunk","encoding","done","chunks","chunklen","i","len","lastPos","buf","length","Buffer","from","slice","push","concat","_flush","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/smtp-connection/data-stream.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this._curLine = '';\n\n        this.inByteCount = 0;\n        this.outByteCount = 0;\n        this.lastByte = false;\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let chunks = [];\n        let chunklen = 0;\n        let i,\n            len,\n            lastPos = 0;\n        let buf;\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk);\n        }\n\n        this.inByteCount += chunk.length;\n\n        for (i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x2e) {\n                // .\n                if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {\n                    buf = chunk.slice(lastPos, i + 1);\n                    chunks.push(buf);\n                    chunks.push(Buffer.from('.'));\n                    chunklen += buf.length + 1;\n                    lastPos = i + 1;\n                }\n            } else if (chunk[i] === 0x0a) {\n                // .\n                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        chunks.push(buf);\n                        chunklen += buf.length + 2;\n                    } else {\n                        chunklen += 2;\n                    }\n                    chunks.push(Buffer.from('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (chunklen) {\n            // add last piece\n            if (lastPos < chunk.length) {\n                buf = chunk.slice(lastPos);\n                chunks.push(buf);\n                chunklen += buf.length;\n            }\n\n            this.outByteCount += chunklen;\n            this.push(Buffer.concat(chunks, chunklen));\n        } else {\n            this.outByteCount += chunk.length;\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n    _flush(done) {\n        let buf;\n        if (this.lastByte === 0x0a) {\n            buf = Buffer.from('.\\r\\n');\n        } else if (this.lastByte === 0x0d) {\n            buf = Buffer.from('\\n.\\r\\n');\n        } else {\n            buf = Buffer.from('\\r\\n.\\r\\n');\n        }\n        this.outByteCount += buf.length;\n        this.push(buf);\n        done();\n    }\n}\n\nmodule.exports = DataStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}