{"ast":null,"code":"/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n'use strict';\n\nconst crypto = require('crypto');\n\nconst fs = require('fs');\n\nconst punycode = require('punycode');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\n\nconst qp = require('../qp');\n\nconst base64 = require('../base64');\n\nconst addressparser = require('../addressparser');\n\nconst nmfetch = require('../fetch');\n\nconst LastNewline = require('./last-newline');\n\nconst LeWindows = require('./le-windows');\n\nconst LeUnix = require('./le-unix');\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\n\n\nclass MimeNode {\n  constructor(contentType, options) {\n    this.nodeCounter = 0;\n    options = options || {};\n    /**\n     * shared part of the unique multipart boundary\n     */\n\n    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n    this.normalizeHeaderKey = options.normalizeHeaderKey;\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n\n    this.date = new Date();\n    /**\n     * Root node for current mime tree\n     */\n\n    this.rootNode = options.rootNode || this;\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n\n    this.keepBcc = !!options.keepBcc;\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n\n    if (options.filename) {\n      /**\n       * Filename for this node. Useful with attachments\n       */\n      this.filename = options.filename;\n\n      if (!contentType) {\n        contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n      }\n    }\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n\n\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n\n    this.parentNode = options.parentNode;\n    /**\n     * Hostname for default message-id values\n     */\n\n    this.hostname = options.hostname;\n    /**\n     * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n     */\n\n    this.newline = options.newline;\n    /**\n     * An array for possible child nodes\n     */\n\n    this.childNodes = [];\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n\n    this._nodeId = ++this.rootNode.nodeCounter;\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n\n    this._headers = [];\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n\n    this._isPlainText = false;\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n\n    this._hasLongLines = false;\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n\n    this._envelope = false;\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n\n    this._raw = false;\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n\n    this._transforms = [];\n    /**\n     * Additional process functions that the message will be piped through before\n     * exposing by createReadStream. These functions are run after transforms\n     * @type {Array}\n     */\n\n    this._processFuncs = [];\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n\n    if (contentType) {\n      this.setHeader('Content-Type', contentType);\n    }\n  } /////// PUBLIC METHODS\n\n  /**\n   * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n   *\n   * @param {String} [contentType] Optional content type\n   * @param {Object} [options] Optional options object\n   * @return {Object} Created node object\n   */\n\n\n  createChild(contentType, options) {\n    if (!options && typeof contentType === 'object') {\n      options = contentType;\n      contentType = undefined;\n    }\n\n    let node = new MimeNode(contentType, options);\n    this.appendChild(node);\n    return node;\n  }\n  /**\n   * Appends an existing node to the mime tree. Removes the node from an existing\n   * tree if needed\n   *\n   * @param {Object} childNode node to be appended\n   * @return {Object} Appended node object\n   */\n\n\n  appendChild(childNode) {\n    if (childNode.rootNode !== this.rootNode) {\n      childNode.rootNode = this.rootNode;\n      childNode._nodeId = ++this.rootNode.nodeCounter;\n    }\n\n    childNode.parentNode = this;\n    this.childNodes.push(childNode);\n    return childNode;\n  }\n  /**\n   * Replaces current node with another node\n   *\n   * @param {Object} node Replacement node\n   * @return {Object} Replacement node\n   */\n\n\n  replace(node) {\n    if (node === this) {\n      return this;\n    }\n\n    this.parentNode.childNodes.forEach((childNode, i) => {\n      if (childNode === this) {\n        node.rootNode = this.rootNode;\n        node.parentNode = this.parentNode;\n        node._nodeId = this._nodeId;\n        this.rootNode = this;\n        this.parentNode = undefined;\n        node.parentNode.childNodes[i] = node;\n      }\n    });\n    return node;\n  }\n  /**\n   * Removes current node from the mime tree\n   *\n   * @return {Object} removed node\n   */\n\n\n  remove() {\n    if (!this.parentNode) {\n      return this;\n    }\n\n    for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n      if (this.parentNode.childNodes[i] === this) {\n        this.parentNode.childNodes.splice(i, 1);\n        this.parentNode = undefined;\n        this.rootNode = this;\n        return this;\n      }\n    }\n  }\n  /**\n   * Sets a header value. If the value for selected key exists, it is overwritten.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n\n\n  setHeader(key, value) {\n    let added = false,\n        headerValue; // Allow setting multiple headers at once\n\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && 'value' in key) {\n        this.setHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.setHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.setHeader(i, key[i]);\n        });\n      }\n\n      return this;\n    }\n\n    key = this._normalizeHeaderKey(key);\n    headerValue = {\n      key,\n      value\n    }; // Check if the value exists and overwrite\n\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        if (!added) {\n          // replace the first match\n          this._headers[i] = headerValue;\n          added = true;\n        } else {\n          // remove following matches\n          this._headers.splice(i, 1);\n\n          i--;\n          len--;\n        }\n      }\n    } // match not found, append the value\n\n\n    if (!added) {\n      this._headers.push(headerValue);\n    }\n\n    return this;\n  }\n  /**\n   * Adds a header value. If the value for selected key exists, the value is appended\n   * as a new field and old one is not touched.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n\n\n  addHeader(key, value) {\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && key.value) {\n        this.addHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.addHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.addHeader(i, key[i]);\n        });\n      }\n\n      return this;\n    } else if (Array.isArray(value)) {\n      value.forEach(val => {\n        this.addHeader(key, val);\n      });\n      return this;\n    }\n\n    this._headers.push({\n      key: this._normalizeHeaderKey(key),\n      value\n    });\n\n    return this;\n  }\n  /**\n   * Retrieves the first mathcing value of a selected key\n   *\n   * @param {String} key Key to search for\n   * @retun {String} Value for the key\n   */\n\n\n  getHeader(key) {\n    key = this._normalizeHeaderKey(key);\n\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        return this._headers[i].value;\n      }\n    }\n  }\n  /**\n   * Sets body content for current node. If the value is a string, charset is added automatically\n   * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n   * the charset yourself\n   *\n   * @param (String|Buffer) content Body content\n   * @return {Object} current node\n   */\n\n\n  setContent(content) {\n    this.content = content;\n\n    if (typeof this.content.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this.content.removeListener('error', this._contentErrorHandler);\n        this.content = err;\n      };\n\n      this.content.once('error', this._contentErrorHandler);\n    } else if (typeof this.content === 'string') {\n      this._isPlainText = mimeFuncs.isPlainText(this.content);\n\n      if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n        // If there are lines longer than 76 symbols/bytes do not use 7bit\n        this._hasLongLines = true;\n      }\n    }\n\n    return this;\n  }\n\n  build(callback) {\n    let promise;\n\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n\n    let stream = this.createReadStream();\n    let buf = [];\n    let buflen = 0;\n    let returned = false;\n    stream.on('readable', () => {\n      let chunk;\n\n      while ((chunk = stream.read()) !== null) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n    });\n    stream.once('error', err => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      return callback(err);\n    });\n    stream.once('end', chunk => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n\n      if (chunk && chunk.length) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n\n      return callback(null, Buffer.concat(buf, buflen));\n    });\n    return promise;\n  }\n\n  getTransferEncoding() {\n    let transferEncoding = false;\n    let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n    if (this.content) {\n      transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n\n      if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n        if (/^text\\//i.test(contentType)) {\n          // If there are no special symbols, no need to modify the text\n          if (this._isPlainText && !this._hasLongLines) {\n            transferEncoding = '7bit';\n          } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n            // detect preferred encoding for string value\n            transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n          } else {\n            // we can not check content for a stream, so either use preferred encoding or fallback to QP\n            transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n          }\n        } else if (!/^(multipart|message)\\//i.test(contentType)) {\n          transferEncoding = transferEncoding || 'base64';\n        }\n      }\n    }\n\n    return transferEncoding;\n  }\n  /**\n   * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n   *\n   * @returns {String} Headers\n   */\n\n\n  buildHeaders() {\n    let transferEncoding = this.getTransferEncoding();\n    let headers = [];\n\n    if (transferEncoding) {\n      this.setHeader('Content-Transfer-Encoding', transferEncoding);\n    }\n\n    if (this.filename && !this.getHeader('Content-Disposition')) {\n      this.setHeader('Content-Disposition', 'attachment');\n    } // Ensure mandatory header fields\n\n\n    if (this.rootNode === this) {\n      if (!this.getHeader('Date')) {\n        this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n      } // ensure that Message-Id is present\n\n\n      this.messageId();\n\n      if (!this.getHeader('MIME-Version')) {\n        this.setHeader('MIME-Version', '1.0');\n      }\n    }\n\n    this._headers.forEach(header => {\n      let key = header.key;\n      let value = header.value;\n      let structured;\n      let param;\n      let options = {};\n      let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n      if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n        Object.keys(value).forEach(key => {\n          if (key !== 'value') {\n            options[key] = value[key];\n          }\n        });\n        value = (value.value || '').toString();\n\n        if (!value.trim()) {\n          return;\n        }\n      }\n\n      if (options.prepared) {\n        // header value is\n        if (options.foldLines) {\n          headers.push(mimeFuncs.foldLines(key + ': ' + value));\n        } else {\n          headers.push(key + ': ' + value);\n        }\n\n        return;\n      }\n\n      switch (header.key) {\n        case 'Content-Disposition':\n          structured = mimeFuncs.parseHeaderValue(value);\n\n          if (this.filename) {\n            structured.params.filename = this.filename;\n          }\n\n          value = mimeFuncs.buildHeaderValue(structured);\n          break;\n\n        case 'Content-Type':\n          structured = mimeFuncs.parseHeaderValue(value);\n\n          this._handleContentType(structured);\n\n          if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n            structured.params.charset = 'utf-8';\n          }\n\n          value = mimeFuncs.buildHeaderValue(structured);\n\n          if (this.filename) {\n            // add support for non-compliant clients like QQ webmail\n            // we can't build the value with buildHeaderValue as the value is non standard and\n            // would be converted to parameter continuation encoding that we do not want\n            param = this._encodeWords(this.filename);\n\n            if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n              // include value in quotes if needed\n              param = '\"' + param + '\"';\n            }\n\n            value += '; name=' + param;\n          }\n\n          break;\n\n        case 'Bcc':\n          if (!this.keepBcc) {\n            // skip BCC values\n            return;\n          }\n\n          break;\n      }\n\n      value = this._encodeHeaderValue(key, value); // skip empty lines\n\n      if (!(value || '').toString().trim()) {\n        return;\n      }\n\n      if (typeof this.normalizeHeaderKey === 'function') {\n        let normalized = this.normalizeHeaderKey(key, value);\n\n        if (normalized && typeof normalized === 'string' && normalized.length) {\n          key = normalized;\n        }\n      }\n\n      headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n    });\n\n    return headers.join('\\r\\n');\n  }\n  /**\n   * Streams the rfc2822 message from the current node. If this is a root node,\n   * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n   *\n   * @return {String} Compiled message\n   */\n\n\n  createReadStream(options) {\n    options = options || {};\n    let stream = new PassThrough(options);\n    let outputStream = stream;\n    let transform;\n    this.stream(stream, options, err => {\n      if (err) {\n        outputStream.emit('error', err);\n        return;\n      }\n\n      stream.end();\n    });\n\n    for (let i = 0, len = this._transforms.length; i < len; i++) {\n      transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n      outputStream.once('error', err => {\n        transform.emit('error', err);\n      });\n      outputStream = outputStream.pipe(transform);\n    } // ensure terminating newline after possible user transforms\n\n\n    transform = new LastNewline();\n    outputStream.once('error', err => {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform); // dkim and stuff\n\n    for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n      transform = this._processFuncs[i];\n      outputStream = transform(outputStream);\n    }\n\n    if (this.newline) {\n      const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n      const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n      const stream = outputStream.pipe(newlineTransform);\n      outputStream.on('error', err => stream.emit('error', err));\n      return stream;\n    }\n\n    return outputStream;\n  }\n  /**\n   * Appends a transform stream object to the transforms list. Final output\n   * is passed through this stream before exposing\n   *\n   * @param {Object} transform Read-Write stream\n   */\n\n\n  transform(transform) {\n    this._transforms.push(transform);\n  }\n  /**\n   * Appends a post process function. The functon is run after transforms and\n   * uses the following syntax\n   *\n   *   processFunc(input) -> outputStream\n   *\n   * @param {Object} processFunc Read-Write stream\n   */\n\n\n  processFunc(processFunc) {\n    this._processFuncs.push(processFunc);\n  }\n\n  stream(outputStream, options, done) {\n    let transferEncoding = this.getTransferEncoding();\n    let contentStream;\n    let localStream; // protect actual callback against multiple triggering\n\n    let returned = false;\n\n    let callback = err => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      done(err);\n    }; // for multipart nodes, push child nodes\n    // for content nodes end the stream\n\n\n    let finalize = () => {\n      let childId = 0;\n\n      let processChildNode = () => {\n        if (childId >= this.childNodes.length) {\n          outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n          return callback();\n        }\n\n        let child = this.childNodes[childId++];\n        outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n        child.stream(outputStream, options, err => {\n          if (err) {\n            return callback(err);\n          }\n\n          setImmediate(processChildNode);\n        });\n      };\n\n      if (this.multipart) {\n        setImmediate(processChildNode);\n      } else {\n        return callback();\n      }\n    }; // pushes node content\n\n\n    let sendContent = () => {\n      if (this.content) {\n        if (Object.prototype.toString.call(this.content) === '[object Error]') {\n          // content is already errored\n          return callback(this.content);\n        }\n\n        if (typeof this.content.pipe === 'function') {\n          this.content.removeListener('error', this._contentErrorHandler);\n\n          this._contentErrorHandler = err => callback(err);\n\n          this.content.once('error', this._contentErrorHandler);\n        }\n\n        let createStream = () => {\n          if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n            contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n            contentStream.pipe(outputStream, {\n              end: false\n            });\n            contentStream.once('end', finalize);\n            contentStream.once('error', err => callback(err));\n            localStream = this._getStream(this.content);\n            localStream.pipe(contentStream);\n          } else {\n            // anything that is not QP or Base54 passes as-is\n            localStream = this._getStream(this.content);\n            localStream.pipe(outputStream, {\n              end: false\n            });\n            localStream.once('end', finalize);\n          }\n\n          localStream.once('error', err => callback(err));\n        };\n\n        if (this.content._resolve) {\n          let chunks = [];\n          let chunklen = 0;\n          let returned = false;\n\n          let sourceStream = this._getStream(this.content);\n\n          sourceStream.on('error', err => {\n            if (returned) {\n              return;\n            }\n\n            returned = true;\n            callback(err);\n          });\n          sourceStream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = sourceStream.read()) !== null) {\n              chunks.push(chunk);\n              chunklen += chunk.length;\n            }\n          });\n          sourceStream.on('end', () => {\n            if (returned) {\n              return;\n            }\n\n            returned = true;\n            this.content._resolve = false;\n            this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n            setImmediate(createStream);\n          });\n        } else {\n          setImmediate(createStream);\n        }\n\n        return;\n      } else {\n        return setImmediate(finalize);\n      }\n    };\n\n    if (this._raw) {\n      setImmediate(() => {\n        if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n          // content is already errored\n          return callback(this._raw);\n        } // remove default error handler (if set)\n\n\n        if (typeof this._raw.pipe === 'function') {\n          this._raw.removeListener('error', this._contentErrorHandler);\n        }\n\n        let raw = this._getStream(this._raw);\n\n        raw.pipe(outputStream, {\n          end: false\n        });\n        raw.on('error', err => outputStream.emit('error', err));\n        raw.on('end', finalize);\n      });\n    } else {\n      outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n      setImmediate(sendContent);\n    }\n  }\n  /**\n   * Sets envelope to be used instead of the generated one\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n\n\n  setEnvelope(envelope) {\n    let list;\n    this._envelope = {\n      from: false,\n      to: []\n    };\n\n    if (envelope.from) {\n      list = [];\n\n      this._convertAddresses(this._parseAddresses(envelope.from), list);\n\n      list = list.filter(address => address && address.address);\n\n      if (list.length && list[0]) {\n        this._envelope.from = list[0].address;\n      }\n    }\n\n    ['to', 'cc', 'bcc'].forEach(key => {\n      if (envelope[key]) {\n        this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n      }\n    });\n    this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n    let standardFields = ['to', 'cc', 'bcc', 'from'];\n    Object.keys(envelope).forEach(key => {\n      if (!standardFields.includes(key)) {\n        this._envelope[key] = envelope[key];\n      }\n    });\n    return this;\n  }\n  /**\n   * Generates and returns an object with parsed address fields\n   *\n   * @return {Object} Address object\n   */\n\n\n  getAddresses() {\n    let addresses = {};\n\n    this._headers.forEach(header => {\n      let key = header.key.toLowerCase();\n\n      if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n        if (!Array.isArray(addresses[key])) {\n          addresses[key] = [];\n        }\n\n        this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n      }\n    });\n\n    return addresses;\n  }\n  /**\n   * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n\n\n  getEnvelope() {\n    if (this._envelope) {\n      return this._envelope;\n    }\n\n    let envelope = {\n      from: false,\n      to: []\n    };\n\n    this._headers.forEach(header => {\n      let list = [];\n\n      if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), list);\n\n        if (list.length && list[0]) {\n          envelope.from = list[0].address;\n        }\n      } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n      }\n    });\n\n    envelope.to = envelope.to.map(to => to.address);\n    return envelope;\n  }\n  /**\n   * Returns Message-Id value. If it does not exist, then creates one\n   *\n   * @return {String} Message-Id value\n   */\n\n\n  messageId() {\n    let messageId = this.getHeader('Message-ID'); // You really should define your own Message-Id field!\n\n    if (!messageId) {\n      messageId = this._generateMessageId();\n      this.setHeader('Message-ID', messageId);\n    }\n\n    return messageId;\n  }\n  /**\n   * Sets pregenerated content that will be used as the output of this node\n   *\n   * @param {String|Buffer|Stream} Raw MIME contents\n   */\n\n\n  setRaw(raw) {\n    this._raw = raw;\n\n    if (this._raw && typeof this._raw.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this._raw.removeListener('error', this._contentErrorHandler);\n\n        this._raw = err;\n      };\n\n      this._raw.once('error', this._contentErrorHandler);\n    }\n\n    return this;\n  } /////// PRIVATE METHODS\n\n  /**\n   * Detects and returns handle to a stream related with the content.\n   *\n   * @param {Mixed} content Node content\n   * @returns {Object} Stream object\n   */\n\n\n  _getStream(content) {\n    let contentStream;\n\n    if (content._resolvedValue) {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => contentStream.end(content._resolvedValue));\n      return contentStream;\n    } else if (typeof content.pipe === 'function') {\n      // assume as stream\n      return content;\n    } else if (content && typeof content.path === 'string' && !content.href) {\n      if (this.disableFileAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n        return contentStream;\n      } // read file\n\n\n      return fs.createReadStream(content.path);\n    } else if (content && typeof content.href === 'string') {\n      if (this.disableUrlAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n        return contentStream;\n      } // fetch URL\n\n\n      return nmfetch(content.href, {\n        headers: content.httpHeaders\n      });\n    } else {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => contentStream.end(content || ''));\n      return contentStream;\n    }\n  }\n  /**\n   * Parses addresses. Takes in a single address or an array or an\n   * array of address arrays (eg. To: [[first group], [second group],...])\n   *\n   * @param {Mixed} addresses Addresses to be parsed\n   * @return {Array} An array of address objects\n   */\n\n\n  _parseAddresses(addresses) {\n    return [].concat.apply([], [].concat(addresses).map(address => {\n      // eslint-disable-line prefer-spread\n      if (address && address.address) {\n        address.address = this._normalizeAddress(address.address);\n        address.name = address.name || '';\n        return [address];\n      }\n\n      return addressparser(address);\n    }));\n  }\n  /**\n   * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n   *\n   * @param {String} key Key to be normalized\n   * @return {String} key in Camel-Case form\n   */\n\n\n  _normalizeHeaderKey(key) {\n    key = (key || '').toString() // no newlines in keys\n    .replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase() // use uppercase words, except MIME\n    .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase()) // special case\n    .replace(/^Content-Features$/i, 'Content-features');\n    return key;\n  }\n  /**\n   * Checks if the content type is multipart and defines boundary if needed.\n   * Doesn't return anything, modifies object argument instead.\n   *\n   * @param {Object} structured Parsed header value for 'Content-Type' key\n   */\n\n\n  _handleContentType(structured) {\n    this.contentType = structured.value.trim().toLowerCase();\n    this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n    if (this.multipart) {\n      this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n    } else {\n      this.boundary = false;\n    }\n  }\n  /**\n   * Generates a multipart boundary value\n   *\n   * @return {String} boundary value\n   */\n\n\n  _generateBoundary() {\n    return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n  }\n  /**\n   * Encodes a header value for use in the generated rfc2822 email.\n   *\n   * @param {String} key Header key\n   * @param {String} value Header value\n   */\n\n\n  _encodeHeaderValue(key, value) {\n    key = this._normalizeHeaderKey(key);\n\n    switch (key) {\n      // Structured headers\n      case 'From':\n      case 'Sender':\n      case 'To':\n      case 'Cc':\n      case 'Bcc':\n      case 'Reply-To':\n        return this._convertAddresses(this._parseAddresses(value));\n      // values enclosed in <>\n\n      case 'Message-ID':\n      case 'In-Reply-To':\n      case 'Content-Id':\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n        if (value.charAt(0) !== '<') {\n          value = '<' + value;\n        }\n\n        if (value.charAt(value.length - 1) !== '>') {\n          value = value + '>';\n        }\n\n        return value;\n      // space separated list of values enclosed in <>\n\n      case 'References':\n        value = [].concat.apply([], [].concat(value || '').map(elm => {\n          // eslint-disable-line prefer-spread\n          elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n          return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n        })).map(elm => {\n          if (elm.charAt(0) !== '<') {\n            elm = '<' + elm;\n          }\n\n          if (elm.charAt(elm.length - 1) !== '>') {\n            elm = elm + '>';\n          }\n\n          return elm;\n        });\n        return value.join(' ').trim();\n\n      case 'Date':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return value.toUTCString().replace(/GMT/, '+0000');\n        }\n\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        return this._encodeWords(value);\n\n      case 'Content-Type':\n      case 'Content-Disposition':\n        // if it includes a filename then it is already encoded\n        return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n      default:\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' '); // encodeWords only encodes if needed, otherwise the original string is returned\n\n        return this._encodeWords(value);\n    }\n  }\n  /**\n   * Rebuilds address object using punycode and other adjustments\n   *\n   * @param {Array} addresses An array of address objects\n   * @param {Array} [uniqueList] An array to be populated with addresses\n   * @return {String} address string\n   */\n\n\n  _convertAddresses(addresses, uniqueList) {\n    let values = [];\n    uniqueList = uniqueList || [];\n    [].concat(addresses || []).forEach(address => {\n      if (address.address) {\n        address.address = this._normalizeAddress(address.address);\n\n        if (!address.name) {\n          values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n        } else if (address.name) {\n          values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n        }\n\n        if (address.address) {\n          if (!uniqueList.filter(a => a.address === address.address).length) {\n            uniqueList.push(address);\n          }\n        }\n      } else if (address.group) {\n        let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n        values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n      }\n    });\n    return values.join(', ');\n  }\n  /**\n   * Normalizes an email address\n   *\n   * @param {Array} address An array of address objects\n   * @return {String} address string\n   */\n\n\n  _normalizeAddress(address) {\n    address = (address || '').toString().replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n    .trim();\n    let lastAt = address.lastIndexOf('@');\n\n    if (lastAt < 0) {\n      // Bare username\n      return address;\n    }\n\n    let user = address.substr(0, lastAt);\n    let domain = address.substr(lastAt + 1); // Usernames are not touched and are kept as is even if these include unicode\n    // Domains are punycoded by default\n    // 'jÃµgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n    // non-unicode domains are left as is\n\n    let encodedDomain;\n\n    try {\n      encodedDomain = punycode.toASCII(domain.toLowerCase());\n    } catch (err) {// keep as is?\n    }\n\n    if (user.indexOf(' ') >= 0) {\n      if (user.charAt(0) !== '\"') {\n        user = '\"' + user;\n      }\n\n      if (user.substr(-1) !== '\"') {\n        user = user + '\"';\n      }\n    }\n\n    return `${user}@${encodedDomain}`;\n  }\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n\n\n  _encodeAddressName(name) {\n    if (!/^[\\w ']*$/.test(name)) {\n      if (/^[\\x20-\\x7e]*$/.test(name)) {\n        return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n      } else {\n        return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n      }\n    }\n\n    return name;\n  }\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n\n\n  _encodeWords(value) {\n    // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n    // by default only words that include non-ascii should be converted into encoded words\n    // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n    return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n  }\n  /**\n   * Detects best mime encoding for a text value\n   *\n   * @param {String} value Value to check for\n   * @return {String} either 'Q' or 'B'\n   */\n\n\n  _getTextEncoding(value) {\n    value = (value || '').toString();\n    let encoding = this.textEncoding;\n    let latinLen;\n    let nonLatinLen;\n\n    if (!encoding) {\n      // count latin alphabet symbols and 8-bit range symbols + control symbols\n      // if there are more latin characters, then use quoted-printable\n      // encoding, otherwise use base64\n      nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n\n      latinLen = (value.match(/[a-z]/gi) || []).length; // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n\n      encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n    }\n\n    return encoding;\n  }\n  /**\n   * Generates a message id\n   *\n   * @return {String} Random Message-ID value\n   */\n\n\n  _generateMessageId() {\n    return '<' + [2, 2, 2, 6].reduce( // crux to generate UUID-like random strings\n    (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'), crypto.randomBytes(4).toString('hex')) + '@' + // try to use the domain of the FROM address or fallback to server hostname\n    (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() + '>';\n  }\n\n}\n\nmodule.exports = MimeNode;","map":{"version":3,"names":["crypto","require","fs","punycode","PassThrough","shared","mimeFuncs","qp","base64","addressparser","nmfetch","LastNewline","LeWindows","LeUnix","MimeNode","constructor","contentType","options","nodeCounter","baseBoundary","randomBytes","toString","boundaryPrefix","disableFileAccess","disableUrlAccess","normalizeHeaderKey","date","Date","rootNode","keepBcc","filename","detectMimeType","split","pop","textEncoding","trim","charAt","toUpperCase","parentNode","hostname","newline","childNodes","_nodeId","_headers","_isPlainText","_hasLongLines","_envelope","_raw","_transforms","_processFuncs","setHeader","createChild","undefined","node","appendChild","childNode","push","replace","forEach","i","remove","length","splice","key","value","added","headerValue","Array","isArray","Object","keys","_normalizeHeaderKey","len","addHeader","val","getHeader","setContent","content","pipe","_contentErrorHandler","err","removeListener","once","isPlainText","hasLongerLines","build","callback","promise","Promise","resolve","reject","callbackPromise","stream","createReadStream","buf","buflen","returned","on","chunk","read","Buffer","concat","getTransferEncoding","transferEncoding","toLowerCase","includes","test","_getTextEncoding","buildHeaders","headers","toUTCString","messageId","header","structured","param","formattedHeaders","prepared","foldLines","parseHeaderValue","params","buildHeaderValue","_handleContentType","match","charset","_encodeWords","_encodeHeaderValue","normalized","join","outputStream","transform","emit","end","winbreak","newlineTransform","processFunc","done","contentStream","localStream","finalize","childId","processChildNode","write","boundary","child","setImmediate","multipart","sendContent","prototype","call","createStream","Encoder","_getStream","_resolve","chunks","chunklen","sourceStream","_resolvedValue","raw","setEnvelope","envelope","list","from","to","_convertAddresses","_parseAddresses","filter","address","map","standardFields","getAddresses","addresses","getEnvelope","_generateMessageId","setRaw","path","href","Error","httpHeaders","apply","_normalizeAddress","name","c","substr","indexOf","_generateBoundary","elm","str","uniqueList","values","_encodeAddressName","a","group","groupListAddresses","lastAt","lastIndexOf","user","domain","encodedDomain","toASCII","encodeWord","encodeWords","encoding","latinLen","nonLatinLen","reduce","prev","module","exports"],"sources":["D:/ReactJS/DoAn_CN/my-app/node_modules/nodemailer/lib/mime-node/index.js"],"sourcesContent":["/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst nmfetch = require('../fetch');\nconst LastNewline = require('./last-newline');\n\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n         */\n        this.newline = options.newline;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        if (this.newline) {\n            const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n\n            const stream = outputStream.pipe(newlineTransform);\n            outputStream.on('error', err => stream.emit('error', err));\n            return stream;\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content._resolvedValue));\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return nmfetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content || ''));\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n                } else if (address.name) {\n                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '')\n            .toString()\n            .replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n            .trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'jÃµgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        let encodedDomain;\n\n        try {\n            encodedDomain = punycode.toASCII(domain.toLowerCase());\n        } catch (err) {\n            // keep as is?\n        }\n\n        if (user.indexOf(' ') >= 0) {\n            if (user.charAt(0) !== '\"') {\n                user = '\"' + user;\n            }\n            if (user.substr(-1) !== '\"') {\n                user = user + '\"';\n            }\n        }\n\n        return `${user}@${encodedDomain}`;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ']*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}